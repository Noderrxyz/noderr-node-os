import axios, { AxiosInstance } from 'axios';
import { UserApplication, NodeType } from '@noderr/types';

/**
 * Typeform API client for handling node operator applications
 */
export class TypeformClient {
  private client: AxiosInstance;
  private formId: string;

  constructor(apiKey: string, formId: string) {
    this.client = axios.create({
      baseURL: 'https://api.typeform.com',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      }
    });
    this.formId = formId;
  }

  /**
   * Fetch all responses from the form
   */
  async fetchResponses(params?: {
    pageSize?: number;
    since?: string;
    until?: string;
    completed?: boolean;
  }): Promise<TypeformResponse[]> {
    try {
      const response = await this.client.get(`/forms/${this.formId}/responses`, {
        params: {
          page_size: params?.pageSize || 100,
          since: params?.since,
          until: params?.until,
          completed: params?.completed !== undefined ? params.completed : true
        }
      });

      return response.data.items || [];
    } catch (error: unknown) {
      throw new Error(`Failed to fetch Typeform responses: ${error.message}`);
    }
  }

  /**
   * Fetch a single response by ID
   */
  async fetchResponse(responseId: string): Promise<TypeformResponse | null> {
    try {
      const response = await this.client.get(`/forms/${this.formId}/responses`, {
        params: {
          included_response_ids: responseId
        }
      });

      const items = response.data.items || [];
      return items.length > 0 ? items[0] : null;
    } catch (error: unknown) {
      throw new Error(`Failed to fetch Typeform response: ${error.message}`);
    }
  }

  /**
   * Parse Typeform response into UserApplication
   */
  parseResponse(response: TypeformResponse): UserApplication {
    const answers = response.answers || [];
    
    // Extract answers by field reference
    const getAnswer = (ref: string): string => {
      const answer = answers.find(a => a.field.ref === ref);
      if (!answer) return '';
      
      if (answer.type === 'email') return answer.email || '';
      if (answer.type === 'text') return answer.text || '';
      if (answer.type === 'choice') return answer.choice?.label || '';
      if (answer.type === 'number') return answer.number?.toString() || '';
      
      return '';
    };

    const email = getAnswer('email');
    const walletAddress = getAnswer('wallet_address');
    const nodeTypeStr = getAnswer('node_type');
    const stakeAmount = parseFloat(getAnswer('stake_amount') || '0');
    const experience = getAnswer('experience');
    const motivation = getAnswer('motivation');

    // Map node type string to enum
    let requestedNodeType: NodeType = NodeType.VALIDATOR;
    if (nodeTypeStr.toUpperCase().includes('ORACLE')) {
      requestedNodeType = NodeType.ORACLE;
    } else if (nodeTypeStr.toUpperCase().includes('GUARDIAN')) {
      requestedNodeType = NodeType.GUARDIAN;
    }

    return {
      id: '', // Will be generated by database
      typeformResponseId: response.response_id,
      email,
      walletAddress,
      requestedNodeType,
      stakeAmount,
      experience,
      motivation,
      status: 'PENDING',
      submittedAt: new Date(response.submitted_at).getTime(),
      metadata: {
        landedAt: response.landed_at,
        calculatedScore: response.calculated?.score,
        allAnswers: answers
      }
    };
  }

  /**
   * Setup webhook for form responses
   */
  async setupWebhook(webhookUrl: string, tag?: string): Promise<WebhookInfo> {
    try {
      const response = await this.client.put(`/forms/${this.formId}/webhooks/${tag || 'noderr'}`, {
        url: webhookUrl,
        enabled: true
      });

      return response.data;
    } catch (error: unknown) {
      throw new Error(`Failed to setup webhook: ${error.message}`);
    }
  }

  /**
   * Get webhook information
   */
  async getWebhook(tag: string = 'noderr'): Promise<WebhookInfo | null> {
    try {
      const response = await this.client.get(`/forms/${this.formId}/webhooks/${tag}`);
      return response.data;
    } catch (error: unknown) {
      if (error.response?.status === 404) {
        return null;
      }
      throw new Error(`Failed to get webhook: ${error.message}`);
    }
  }

  /**
   * Delete webhook
   */
  async deleteWebhook(tag: string = 'noderr'): Promise<void> {
    try {
      await this.client.delete(`/forms/${this.formId}/webhooks/${tag}`);
    } catch (error: unknown) {
      throw new Error(`Failed to delete webhook: ${error.message}`);
    }
  }

  /**
   * Verify webhook signature
   */
  static verifyWebhookSignature(
    payload: string,
    signature: string,
    secret: string
  ): boolean {
    const crypto = require('crypto');
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(payload);
    const expectedSignature = `sha256=${hmac.digest('base64')}`;
    
    return signature === expectedSignature;
  }
}

// Types
export interface TypeformResponse {
  response_id: string;
  landed_at: string;
  submitted_at: string;
  calculated?: {
    score: number;
  };
  answers: TypeformAnswer[];
}

export interface TypeformAnswer {
  field: {
    id: string;
    ref: string;
    type: string;
  };
  type: string;
  text?: string;
  email?: string;
  number?: number;
  boolean?: boolean;
  choice?: {
    label: string;
    other?: string;
  };
  choices?: {
    labels: string[];
  };
}

export interface WebhookInfo {
  id: string;
  form_id: string;
  tag: string;
  url: string;
  enabled: boolean;
  created_at: string;
  updated_at: string;
}
