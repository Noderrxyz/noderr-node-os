// Numeric type to support both number and BigNumber
export type Numeric = number | any; // any to support BigNumber without importing it

// ============================================================================
// Alpha Types
// ============================================================================

export enum AlphaType {
  ARBITRAGE = 'arbitrage',
  MOMENTUM = 'momentum',
  MEAN_REVERSION = 'mean_reversion',
  STATISTICAL = 'statistical',
  MARKET_MAKING = 'market_making',
  LIQUIDITY_PROVISION = 'liquidity_provision',
  VOLATILITY = 'volatility',
  CORRELATION = 'correlation',
  VOLATILITY_CAPTURE = 'volatility_capture',
  MICROSTRUCTURE = 'microstructure',
  CROSS_VENUE = 'cross_venue',
}

export enum AlphaSource {
  ORDERBOOK = 'orderbook',
  TRADES = 'trades',
  FUNDING_RATE = 'funding_rate',
  LIQUIDITY_IMBALANCE = 'liquidity_imbalance',
  PRICE_DIVERGENCE = 'price_divergence',
  ORDERBOOK_IMBALANCE = 'orderbook_imbalance',
  MICROSTRUCTURE_SIGNAL = 'microstructure_signal',
  CROSS_EXCHANGE = 'cross_exchange',
  DEX_CEX_SPREAD = 'dex_cex_spread',
  AI_PREDICTION = 'ai_prediction',
}

export enum AlphaPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
  NORMAL = 'normal',
}

export interface AlphaOpportunity {
  id: string;
  type: AlphaType;
  source: AlphaSource;
  priority: AlphaPriority;
  expectedReturn: number;
  confidence: number;
  timeWindow: number;
  venue?: string;
  symbol?: string;
  metadata?: Record<string, any>;
  timestamp: number;
  riskScore?: number;
  capital?: Numeric;
  timeHorizon?: number;
}

export interface AlphaPerformance {
  opportunityId: string;
  realized: boolean;
  actualReturn: number;
  executionTime: number;
  slippage: number;
  gasUsed: bigint;
  timestamp: number;
  executionMetrics?: { latency?: number; [key: string]: any };
  successRate?: number;
  opportunitiesIdentified?: number;
  opportunitiesExecuted?: number;
  totalPnL?: Numeric;
  hitRate?: number;
  sharpeRatio?: number;
  maxDrawdown?: number;
  profitFactor?: number;
  averageReturn?: number;
  returnVolatility?: number;
}

// ============================================================================
// Arbitrage Types
// ============================================================================

export enum ArbitrageType {
  CROSS_EXCHANGE = 'cross_exchange',
  TRIANGULAR = 'triangular',
  STATISTICAL = 'statistical',
  FUNDING_RATE = 'funding_rate',
  CROSS_CHAIN = 'cross_chain',
  SPOT = 'spot',
  DEX_CEX = 'dex_cex',
}

export enum ArbitrageRisk {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  EXTREME = 'extreme'
}

export interface ArbitrageOpportunity {
  type: ArbitrageType;
  venues: string[];
  assets: string[];
  expectedProfit: Numeric;
  estimatedCost: Numeric;
  netProfit: Numeric;
  risk: ArbitrageRisk;
  timeWindow: number;
  confidence: number;
  timestamp: number;
}

// ============================================================================
// Market Microstructure Types
// ============================================================================

export enum MicrostructureSignalType {
  ORDER_FLOW_IMBALANCE = 'order_flow_imbalance',
  HIDDEN_LIQUIDITY = 'hidden_liquidity',
  SPREAD_ANOMALY = 'spread_anomaly',
  DEPTH_IMBALANCE = 'depth_imbalance',
  VOLUME_SPIKE = 'volume_spike',
  PRICE_IMPACT = 'price_impact',
  TOXIC_FLOW = 'toxic_flow',
  INVENTORY_PRESSURE = 'inventory_pressure',
}

export interface MicrostructureSignal {
  type: MicrostructureSignalType;
  venue: string;
  symbol: string;
  strength: number;
  confidence: number;
  timestamp: number;
  metadata?: Record<string, any>;
}

// Order Flow Analysis - Matches actual implementation
export interface OrderFlowMetrics {
  buyVolume?: number;
  sellVolume?: number;
  netVolume?: number;
  buyPressure: number;
  sellPressure: number;
  largeOrderRatio: number;
  oddLotRatio: number;
  sweepRatio: number;
}

export interface OrderFlowAnalysis {
  venue: string;
  symbol: string;
  period: number;
  metrics: OrderFlowMetrics;
  classification: string | Record<string, number>;
  toxicity: number | ToxicityScore;
  buyVolume?: Numeric;  // Optional for compatibility
  sellVolume?: Numeric; // Optional for compatibility
  netFlow?: Numeric;    // Optional for compatibility
  vwap?: number;        // Optional for compatibility
  imbalance?: number;   // Optional for compatibility
  timestamp?: number;   // Optional for compatibility
  buyFlow?: Numeric;    // Optional for compatibility
  sellFlow?: Numeric;   // Optional for compatibility
  largeOrderFlow?: boolean; // Optional for compatibility
  smartMoneyFlow?: Numeric; // Optional for compatibility
  sentiment?: string | number; // Optional for compatibility
}

// Complex nested types for microstructure analysis
export interface ToxicityScore {
  score: number;
  components: {
    adverseSelection: number;
    inventoryRisk: number;
    informationAsymmetry: number;
  };
}

export interface SpreadDynamics {
  absolute: number;
  relative: number;
  trend: 'widening' | 'narrowing' | 'stable';
  symbol?: string;
  bidAskSpread?: number;
  effectiveSpread?: number;
  realizedSpread?: number;
  spreadVolatility?: number;
}

export interface MarketDepthProfile {
  symbol: string;
  venue: string;
  bids: Array<{ price: number; size: number }>;
  asks: Array<{ price: number; size: number }>;
  totalBidVolume: number;
  totalAskVolume: number;
  depthImbalance: number;
  imbalance?: number;
  timestamp: number;
  percentiles?: VolumePercentiles;
  levels?: number | DepthLevel[]; // Can be count or array
  profile?: any; // Additional profile data
  dynamics?: any; // Depth dynamics data
}

export interface VolumeDistribution {
  symbol: string;
  venue: string;
  distribution: number[];
  mean: number;
  median: number;
  stdDev: number;
  skewness: number;
  kurtosis: number;
  strength: number;
  confidence: number;
  timestamp: number;
  percentiles?: VolumePercentiles;
  metadata?: Record<string, any>;
  gini?: number;
}

export interface VolumePercentiles {
  p10: number;
  p25: number;
  p50: number;
  p75: number;
  p90: number;
  p95: number;
  p99: number;
}

export interface DepthLevel {
  price: number;
  size: number;
  cumulativeSize: number;
}

export interface HiddenLiquidity {
  venue: string;
  symbol: string;
  estimatedSize: number;
  confidence: number;
  detectionMethod?: string;
  timestamp?: number;
  type?: string;
  priceLevel?: number;
  detected?: boolean;
  behavior?: any;
}

export interface MarketImpactModel {
  symbol: string;
  venue?: string;
  permanentImpact: number;
  temporaryImpact: number;
  temporary?: number | { linear: number; squareRoot: number; parameters: any }; // Can be simple or complex
  permanent?: number; // Alias for permanentImpact
  liquidityParameter: number;
  volatility: number;
  decay?: any; // Decay parameters
}

export interface LiquidityMetrics {
  available: Numeric;
  resilience: number;
  replenishmentRate: number;
}

export interface MarketMicrostructure {
  venue: string;
  symbol: string;
  timestamp: number;
  spread: SpreadDynamics;
  depth: MarketDepthProfile;
  orderFlow: OrderFlowAnalysis;
  liquidity?: number | LiquidityMetrics;
}

// ============================================================================
// Market Regime Types
// ============================================================================

export interface RegimeAnalysis {
  currentRegime: string;
  confidence: number;
  duration: number;
  transitions: Array<{
    from: string;
    to: string;
    timestamp: number;
  }>;
}

// ============================================================================
// Protection Types
// ============================================================================

export enum ThreatType {
  FRONT_RUNNING = 'front_running',
  SANDWICH_ATTACK = 'sandwich_attack',
  WASH_TRADING = 'wash_trading',
  SPOOFING = 'spoofing',
  LAYERING = 'layering',
  QUOTE_STUFFING = 'quote_stuffing',
  MOMENTUM_IGNITION = 'momentum_ignition',
  MANIPULATION = 'manipulation',
  API_ABUSE = 'api_abuse',
  PUMP_DUMP = 'pump_dump',
}

export interface ThreatDetection {
  id?: string;
  type: ThreatType;
  severity: 'low' | 'medium' | 'high' | 'critical';
  confidence: number;
  affectedVenues?: string[];
  affectedAssets?: string[];
  detectionTime?: number;
  evidence?: Record<string, any>;
  target?: string;
  timestamp?: number;
  source?: string;
  indicators?: ThreatIndicator[];
  suggestedAction?: any;
  metadata?: Record<string, any>;
}

export interface MarketManipulation {
  type: string;
  venue: string;
  symbol: string;
  confidence: number;
  evidence: string[];
  timestamp: number;
}

// ============================================================================
// Insight Types
// ============================================================================

export enum InsightType {
  OPPORTUNITY = 'opportunity',
  RISK = 'risk',
  MARKET_CONDITION = 'market_condition',
  CORRELATION_BREAK = 'correlation_break',
  REGIME_CHANGE = 'regime_change',
  MARKET_STRUCTURE = 'market_structure',
  PERFORMANCE_ALERT = 'performance_alert',
  UNUSUAL_ACTIVITY = 'unusual_activity',
}

export interface MarketInsight {
  type: InsightType;
  priority: 'low' | 'medium' | 'high';
  title?: string;
  description?: string;
  confidence: number;
  timestamp: number;
  data?: Record<string, any>;
  message?: string;
}

export interface CorrelationMatrix {
  symbols: string[];
  matrix: number[][];
  timestamp: number;
  period?: number | string;
}

// ============================================================================
// Configuration
// ============================================================================

export interface AlphaExploitationConfig {
  enabled: boolean;
  minConfidence?: number;
  maxRisk?: number;
  minExpectedReturn?: number;
  executionMode?: 'conservative' | 'moderate' | 'aggressive';
  capitalAllocation?: { maxPerOpportunity: Numeric; maxTotal?: Numeric; reserveRatio?: number };
  venues?: string[];
  mode?: string;
  strategies?: string[];
  maxRiskScore?: number;
  execution?: { mode?: string; [key: string]: any };
  maxCapitalPerOpportunity?: number;
  maxTotalCapital?: number;
  reserveRatio?: number;
  analytics?: { enabled?: boolean; [key: string]: any };
  riskLimits?: { maxDrawdown?: number; maxLoss?: number; [key: string]: any };
  defense?: { antiManipulation?: boolean; adversarialDetection?: boolean; emergencyStop?: boolean; [key: string]: any };
}

// ============================================================================
// Execution Mode
// ============================================================================

export enum ExecutionMode {
  CONSERVATIVE = 'conservative',
  MODERATE = 'moderate',
  AGGRESSIVE = 'aggressive',
  ADAPTIVE = 'adaptive',
  STEALTH = 'stealth',
  PASSIVE = 'passive',
}

export interface ExecutionStep {
  action: string;
  venue: string;
  asset: string;
  amount: number;
  expectedPrice: number;
  maxSlippage: number;
  timeout: number;
  size?: number; // Optional size field
}

// ============================================================================
// Backtest Types
// ============================================================================

export interface BacktestResult {
  strategyId: string;
  startTime: number;
  endTime: number;
  totalReturn: number;
  sharpeRatio: number;
  maxDrawdown: number;
  winRate: number;
  totalTrades: number;
  tradesExecuted?: number; // Alias for totalTrades
  profitableTrades: number;
  averageProfit: number;
  averageLoss: number;
  metadata?: Record<string, any>;
}

// Export type alias for compatibility
export type FlowAnalysis = OrderFlowAnalysis;

// ============================================================================
// Additional Arbitrage Types
// ============================================================================

export interface TradingPair {
  base: string;
  quote: string;
  symbol: string;
  venue: string;
}

export interface TriangularArbitrage {
  path: string[];
  startCurrency: string;
  endCurrency: string;
  expectedProfit: number;
  confidence: number;
  venues: string[];
  timestamp: number;
}

export interface StatisticalArbitrage {
  pair1: TradingPair;
  pair2: TradingPair;
  spread: number;
  zScore: number;
  expectedReturn: number;
  confidence: number;
  timestamp: number;
}

export enum ExecutionUrgency {
  LOW = 'low',
  NORMAL = 'normal',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export enum MEVProtectionLevel {
  NONE = 'none',
  LOW = 'low',
  MEDIUM = 'medium',
  ENHANCED = 'enhanced',
  HIGH = 'high',
  MAXIMUM = 'maximum',
}

// ============================================================================
// Market Insights Types
// ============================================================================

export enum InsightPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface VolumeProfile {
  symbol: string;
  venue: string;
  timestamp: number;
  totalVolume: number;
  buyVolume: number;
  sellVolume: number;
  vwap: number;
  priceRanges: Array<{
    price: number;
    volume: number;
    percentage: number;
  }>;
  pocPrice?: number; // Point of Control - price with highest volume
  valueArea?: {
    high: number;
    low: number;
    percentage: number;
  };
}

// ============================================================================
// Defense Types
// ============================================================================

export enum ThreatSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical',
}

export interface ThreatIndicator {
  type: string;
  value: number;
  threshold: number;
  timestamp: number;
  description?: string;
  confidence?: number;
}

export interface DefensiveAction {
  id: string;
  type: DefenseActionType;
  threatId: string;
  timestamp: number;
  status: 'pending' | 'active' | 'completed' | 'failed';
  parameters: Record<string, any>;
  result?: any;
}

export enum DefenseActionType {
  PAUSE_TRADING = 'pause_trading',
  REDUCE_POSITION = 'reduce_position',
  CANCEL_ORDERS = 'cancel_orders',
  SWITCH_VENUE = 'switch_venue',
  INCREASE_SLIPPAGE_TOLERANCE = 'increase_slippage_tolerance',
  ALERT_OPERATOR = 'alert_operator',
  REDUCE_EXPOSURE = 'reduce_exposure',
  DELAY_EXECUTION = 'delay_execution',
  ALERT_ONLY = 'alert_only',
  ADJUST_SPREADS = 'adjust_spreads',
  EMERGENCY_STOP = 'emergency_stop',
  ENABLE_PROTECTION = 'enable_protection',
}

export enum ManipulationType {
  SPOOFING = 'spoofing',
  LAYERING = 'layering',
  WASH_TRADING = 'wash_trading',
  PUMP_DUMP = 'pump_dump',
  FRONT_RUNNING = 'front_running',
  QUOTE_STUFFING = 'quote_stuffing',
}

export interface ManipulationEvidence {
  type: ManipulationType;
  indicators: ThreatIndicator[];
  confidence: number;
  description: string;
  timestamp: number;
}

export enum ProtectionStatusEnum {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  PAUSED = 'paused',
  ERROR = 'error',
}

export interface ProtectionStatus {
  active: boolean;
  level: string;
  activeMeasures: ActiveProtection[];
  recentThreats: ThreatDetection[];
  performance: {
    threatsDetected: number;
    attacksPrevented: number;
    falsePositives: number;
    avgResponseTime: number;
  };
}

export interface ActiveProtection {
  id?: string;
  type: ProtectionType;
  status?: ProtectionStatusEnum;
  enabled?: boolean;
  startTime?: number;
  parameters?: Record<string, any>;
  effectiveness?: number;
  cost?: number;
  metrics?: {
    threatsDetected: number;
    actionsTaken: number;
    effectiveness: number;
  };
}

export enum ProtectionType {
  MEV_PROTECTION = 'mev_protection',
  SANDWICH_PROTECTION = 'sandwich_protection',
  FRONT_RUN_PROTECTION = 'front_run_protection',
  SLIPPAGE_PROTECTION = 'slippage_protection',
  MANIPULATION_DETECTION = 'manipulation_detection',
  EXECUTION_DELAY = 'execution_delay',
  ORDER_RANDOMIZATION = 'order_randomization',
  SPLIT_ROUTING = 'split_routing',
}
