/**
 * AlphaExploitationService - Elite 0.01% Alpha Generation Core
 * 
 * Main orchestration service for the alpha exploitation module.
 * Coordinates all components and manages opportunity lifecycle.
 */

import { EventEmitter } from 'events';
import { Logger } from 'winston';
import {
  Message,
  MessageType,
  MessageFactory,
  SystemOrchestrator
} from '@noderr/integration-layer';
import {
  AlphaOpportunity,
  AlphaType,
  AlphaSource,
  AlphaPriority,
  AlphaExploitationConfig,
  AlphaPerformance,
  ExecutionMode,
  MEVProtectionLevel
} from '@noderr/types';
import { BigNumber } from 'bignumber.js';
import { SmartLiquidityAggregator } from '../liquidity/SmartLiquidityAggregator';
import { ArbitrageEngine } from '../arbitrage/ArbitrageEngine';
import { MicrostructureAnalyzer } from '../microstructure/MicrostructureAnalyzer';
import { MarketDefender } from '../defense/MarketDefender';
import { MarketAnalytics } from '../analytics/MarketAnalytics';
import { DEFAULT_CONFIG, PERFORMANCE_TARGETS } from '@noderr/config/default';

// Mock integration layer types for now
interface MessageFactory {
  create(type: string, from: string, to: string, data: any): any;
}

interface Orchestrator {
  sendMessage(message: any): Promise<void>;
}

enum MessageType {
  RISK_ALERT = 'RISK_ALERT',
  ORDER_REQUEST = 'ORDER_REQUEST'
}

const MessageFactory: MessageFactory = {
  create: (type: string, from: string, to: string, data: any) => ({
    type, from, to, data, timestamp: Date.now()
  })
};

interface AlphaExploitationServiceConfig extends AlphaExploitationConfig {
  // Additional service-specific config
}

export class AlphaExploitationService extends EventEmitter {
  private config: AlphaExploitationConfig;
  private logger: Logger;
  private orchestrator?: SystemOrchestrator;
  
  // Components
  private liquidityAggregator!: SmartLiquidityAggregator;
  private arbitrageEngine!: ArbitrageEngine;
  private microstructureAnalyzer!: MicrostructureAnalyzer;
  private marketDefender!: MarketDefender;
  private marketAnalytics!: MarketAnalytics;
  
  // State
  private activeOpportunities: Map<string, AlphaOpportunity> = new Map();
  private performance: AlphaPerformance;
  private isRunning: boolean = false;
  private emergencyStopActive: boolean = false;
  
  // Metrics
  private opportunityCount: number = 0;
  private executedCount: number = 0;
  private totalPnL: BigNumber = new BigNumber(0);
  private startTime: number = Date.now();

  constructor(config: Partial<AlphaExploitationConfig> = {}) {
    super();
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.logger = this.createLogger();
    
    // Initialize performance metrics
    this.performance = this.initializePerformance();
    
    this.setupEventHandlers();
    this.logger.info('AlphaExploitationService initialized', {
      mode: this.config.mode,
      strategies: this.config.strategies?.length || 0,
      venues: this.config.venues?.length || 0
    });
  }

  /**
   * Start the alpha exploitation service
   */
  async start(): Promise<void> {
    if (this.isRunning) {
      this.logger.warn('AlphaExploitationService already running');
      return;
    }

    try {
      this.logger.info('Starting AlphaExploitationService...');
      
      // Initialize all components
      await this.initializeComponents();
      
      // Start all components
      await Promise.all([
        this.liquidityAggregator.start(),
        this.arbitrageEngine.start(),
        this.microstructureAnalyzer.start(),
        this.marketDefender.start(),
        this.marketAnalytics.start()
      ]);
      
      // Register with orchestrator if available
      if (this.orchestrator) {
        await this.registerWithOrchestrator();
      }
      
      // Start opportunity scanning
      this.startOpportunityScanning();
      
      this.isRunning = true;
      this.emit('started');
      this.logger.info('AlphaExploitationService started successfully');
      
    } catch (error) {
      this.logger.error('Failed to start AlphaExploitationService', error);
      throw error;
    }
  }

  /**
   * Stop the alpha exploitation service
   */
  async stop(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    try {
      this.logger.info('Stopping AlphaExploitationService...');
      
      // Cancel all active opportunities
      await this.cancelAllOpportunities();
      
      // Stop all components
      await Promise.all([
        this.liquidityAggregator.stop(),
        this.arbitrageEngine.stop(),
        this.microstructureAnalyzer.stop(),
        this.marketDefender.stop(),
        this.marketAnalytics.stop()
      ]);
      
      this.isRunning = false;
      this.emit('stopped');
      this.logger.info('AlphaExploitationService stopped successfully');
      
    } catch (error) {
      this.logger.error('Error stopping AlphaExploitationService', error);
      throw error;
    }
  }

  /**
   * Emergency stop - immediately halt all trading
   */
  async emergencyStop(): Promise<void> {
    this.logger.warn('EMERGENCY STOP TRIGGERED');
    this.emergencyStopActive = true;
    
    // Cancel all orders immediately
    await this.cancelAllOpportunities();
    
    // Stop all components
    await this.stop();
    
    // Send emergency alert
    if (this.orchestrator) {
      const message = MessageFactory.create(
        MessageType.RISK_ALERT,
        'alpha-exploitation',
        'risk-engine',
        {
          type: 'EMERGENCY_STOP',
          reason: 'Manual trigger',
          timestamp: Date.now()
        }
      );
      await this.orchestrator.sendMessage(message);
    }
    
    this.emit('emergency-stop');
  }

  /**
   * Process a new alpha opportunity
   */
  private async processOpportunity(opportunity: AlphaOpportunity): Promise<void> {
    const startTime = process.hrtime.bigint();
    
    try {
      // Validate opportunity
      if (!this.validateOpportunity(opportunity)) {
        return;
      }
      
      // Check risk limits
      const riskApproved = await this.checkRiskLimits(opportunity);
      if (!riskApproved) {
        this.logger.warn('Opportunity rejected by risk engine', {
          id: opportunity.id,
          reason: 'risk_limits'
        });
        return;
      }
      
      // Check for market manipulation
      const isSafe = await this.marketDefender.checkOpportunity(opportunity);
      if (!isSafe) {
        this.logger.warn('Opportunity rejected by market defender', {
          id: opportunity.id,
          reason: 'manipulation_detected'
        });
        return;
      }
      
      // Store opportunity
      this.activeOpportunities.set(opportunity.id, opportunity);
      
      // Execute based on priority
      if (opportunity.priority === AlphaPriority.CRITICAL) {
        await this.executeOpportunityImmediate(opportunity);
      } else {
        await this.scheduleOpportunityExecution(opportunity);
      }
      
      // Update metrics
      const latency = Number(process.hrtime.bigint() - startTime) / 1e6;
      this.updatePerformanceMetrics(opportunity, latency);
      
    } catch (error) {
      this.logger.error('Error processing opportunity', {
        id: opportunity.id,
        error: error instanceof Error ? error.message : String(error)
      });
      this.handleOpportunityError(opportunity, error);
    }
  }

  /**
   * Validate opportunity meets criteria
   */
  private validateOpportunity(opportunity: AlphaOpportunity): boolean {
    // Check confidence threshold
    if (opportunity.confidence < this.config.minConfidence) {
      return false;
    }
    
    // Check expected return
    if (opportunity.expectedReturn < this.config.minExpectedReturn) {
      return false;
    }
    
    // Check risk score
    if ((opportunity.riskScore || 0) > (this.config.maxRiskScore || 100)) {
      return false;
    }
    
    // Check if strategy is enabled
    if (!this.config.strategies?.includes(opportunity.type)) {
      return false;
    }
    
    // Check capital requirements
    const availableCapital = this.getAvailableCapital();
    if (opportunity.capital?.gt(availableCapital)) {
      return false;
    }
    
    return true;
  }

  /**
   * Check risk limits for opportunity
   */
  private async checkRiskLimits(opportunity: AlphaOpportunity): Promise<boolean> {
    if (!this.orchestrator) {
      return true; // Pass if no orchestrator
    }
    
    const message = MessageFactory.create(
      MessageType.RISK_ALERT,
      'alpha-exploitation',
      'risk-engine',
      {
        type: 'CHECK_LIMITS',
        opportunity: opportunity,
        requestId: opportunity.id
      }
    );
    
    // Send risk check request
    const response = await this.orchestrator.sendMessage(message, 1000);
    return response?.payload?.approved === true;
  }

  /**
   * Execute opportunity immediately
   */
  private async executeOpportunityImmediate(opportunity: AlphaOpportunity): Promise<void> {
    const message = MessageFactory.create(
      MessageType.ORDER_REQUEST,
      'alpha-exploitation',
      'execution-optimizer',
      {
        opportunityId: opportunity.id,
        type: opportunity.type,
        capital: opportunity.capital.toString(),
        urgency: 'immediate',
        config: this.config.execution
      }
    );
    
    if (this.orchestrator) {
      await this.orchestrator.sendMessage(message);
    }
    
    this.executedCount++;
    this.emit('opportunity-executed', opportunity);
  }

  /**
   * Schedule opportunity for optimal execution
   */
  private async scheduleOpportunityExecution(opportunity: AlphaOpportunity): Promise<void> {
    // Calculate optimal execution time based on market conditions
    const executionDelay = this.calculateExecutionDelay(opportunity);
    
    setTimeout(async () => {
      if (this.activeOpportunities.has(opportunity.id)) {
        await this.executeOpportunityImmediate(opportunity);
      }
    }, executionDelay);
  }

  /**
   * Calculate optimal execution delay
   */
  private calculateExecutionDelay(opportunity: AlphaOpportunity): number {
    // Base delay on priority
    let delay = 0;
    switch (opportunity.priority) {
      case AlphaPriority.HIGH:
        delay = Math.random() * 100; // 0-100ms
        break;
      case AlphaPriority.NORMAL:
        delay = 100 + Math.random() * 900; // 100-1000ms
        break;
      case AlphaPriority.LOW:
        delay = 1000 + Math.random() * 4000; // 1-5s
        break;
    }
    
    // Add randomization if in stealth mode
    if (this.config.execution.mode === ExecutionMode.STEALTH) {
      delay += Math.random() * 500;
    }
    
    return Math.min(delay, opportunity.timeHorizon);
  }

  /**
   * Get available capital for trading
   */
  private getAvailableCapital(): BigNumber {
    const totalCapital = new BigNumber(this.config.capitalAllocation?.maxTotal || 1000000);
    const reserveRatio = this.config.capitalAllocation?.reserveRatio || 0.1;
    const activeCapital = Array.from(this.activeOpportunities.values())
      .reduce((sum, opp) => sum.plus(opp.capital), new BigNumber(0));
    
    return totalCapital
      .times(1 - reserveRatio)
      .minus(activeCapital);
  }

  /**
   * Cancel all active opportunities
   */
  private async cancelAllOpportunities(): Promise<void> {
    const promises = Array.from(this.activeOpportunities.keys()).map(id =>
      this.cancelOpportunity(id)
    );
    await Promise.all(promises);
  }

  /**
   * Cancel specific opportunity
   */
  private async cancelOpportunity(id: string): Promise<void> {
    if (!this.activeOpportunities.has(id)) {
      return;
    }
    
    const opportunity = this.activeOpportunities.get(id)!;
    this.activeOpportunities.delete(id);
    
    if (this.orchestrator) {
      const message = MessageFactory.create(
        MessageType.ORDER_REQUEST,
        'alpha-exploitation',
        'execution-optimizer',
        {
          action: 'CANCEL',
          opportunityId: id
        }
      );
      await this.orchestrator.sendMessage(message);
    }
    
    this.emit('opportunity-cancelled', opportunity);
  }

  /**
   * Setup event handlers for components
   */
  private setupEventHandlers(): void {
    // Liquidity events
    this.liquidityAggregator.on('liquidity-update', (update) => this.handleLiquidityUpdate(update));
    this.liquidityAggregator.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Arbitrage events
    this.arbitrageEngine.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Microstructure events
    this.microstructureAnalyzer.on('signal', (signal) => this.handleMicrostructureSignal(signal));
    this.microstructureAnalyzer.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Defense events
    this.marketDefender.on('threat', (threat) => this.handleThreat(threat));
    this.marketDefender.on('emergency-stop', (params) => this.handleEmergencyStop(params));
    this.marketDefender.on('reduce-exposure', (params) => this.handleReduceExposure(params));
    this.marketDefender.on('switch-venue', (params) => this.handleSwitchVenue(params));
    this.marketDefender.on('protection-enabled', (params) => this.handleProtectionEnabled(params));
    
    // Analytics events
    this.marketAnalytics.on('insight', (insight) => this.handleInsight(insight));
    this.marketAnalytics.on('regime-change', (change) => this.handleRegimeChange(change));
    this.marketAnalytics.on('metrics-export', (metrics) => this.handleMetricsExport(metrics));
  }

  /**
   * Handle microstructure signal
   */
  private async handleMicrostructureSignal(signal: any): Promise<void> {
    // Convert signal to opportunity if actionable
    if (signal.strength > 0.7 && signal.confidence > 0.8) {
      const opportunity: AlphaOpportunity = {
        id: `micro_${Date.now()}_${Math.random()}`,
        type: AlphaType.MICROSTRUCTURE,
        source: AlphaSource.MICROSTRUCTURE_SIGNAL,
        confidence: signal.confidence,
        expectedReturn: signal.expectedReturn || 15,
        riskScore: 0.2,
        timeHorizon: 1000,
        capital: new BigNumber('50000'),
        priority: AlphaPriority.HIGH,
        timeWindow: 60000,
        timestamp: Date.now(),
        metadata: signal
      };
      
      await this.processOpportunity(opportunity);
    }
  }

  /**
   * Handle threat detection
   */
  private async handleThreat(threat: any): Promise<void> {
    this.logger.warn('Threat detected', threat);
    
    // Take defensive action based on severity
    if (threat.severity === 'CRITICAL') {
      await this.emergencyStop();
    } else if (threat.severity === 'HIGH') {
      // Reduce exposure
      this.config.capitalAllocation.maxPerOpportunity = 
        this.config.capitalAllocation.maxPerOpportunity.div(2);
      
      // Increase protection
      this.config.execution.mevProtection = MEVProtectionLevel.MAXIMUM;
    }
    
    this.emit('threat-detected', threat);
  }

  /**
   * Handle market insight
   */
  private async handleInsight(insight: any): Promise<void> {
    if (insight.actionable && insight.confidence > 0.8) {
      // Adjust strategies based on insight
      this.adjustStrategies(insight);
    }
    
    this.emit('market-insight', insight);
  }

  /**
   * Adjust strategies based on market conditions
   */
  private adjustStrategies(insight: any): void {
    // Example adjustments based on insights
    switch (insight.type) {
      case 'VOLATILITY_REGIME':
        if (insight.data.regime === 'high_volatility') {
          // Reduce position sizes
          this.config.capitalAllocation.maxPerOpportunity = 
            this.config.capitalAllocation.maxPerOpportunity.times(0.7);
          // Increase slippage tolerance
          this.config.execution.slippageTolerance *= 1.5;
        }
        break;
        
      case 'LIQUIDITY_SHIFT':
        if (insight.data.liquidity === 'low') {
          // Switch to passive execution
          this.config.execution.mode = ExecutionMode.PASSIVE;
          // Reduce max impact
          this.config.execution.maxImpact *= 0.5;
        }
        break;
    }
  }

  /**
   * Start opportunity scanning
   */
  private startOpportunityScanning(): void {
    // Main scanning loop
    setInterval(() => {
      if (!this.emergencyStopActive && this.isRunning) {
        this.scanForOpportunities();
      }
    }, this.config.analytics.updateFrequency);
  }

  /**
   * Scan all sources for opportunities
   */
  private async scanForOpportunities(): Promise<void> {
    try {
      // Get market state
      const marketState = await this.marketAnalytics.getMarketState();
      
      // Update components with market state
      this.liquidityAggregator.updateMarketState(marketState);
      this.arbitrageEngine.updateMarketState(marketState);
      this.microstructureAnalyzer.updateMarketState(marketState);
      
      // Components will emit opportunities through events
      
    } catch (error) {
      this.logger.error('Error scanning for opportunities', error);
    }
  }

  /**
   * Update performance metrics
   */
  private updatePerformanceMetrics(
    opportunity: AlphaOpportunity,
    latency: number
  ): void {
    this.opportunityCount++;
    
    // Update latency tracking
    this.performance.executionMetrics.avgLatency = 
      (this.performance.executionMetrics.avgLatency * (this.opportunityCount - 1) + latency) / 
      this.opportunityCount;
    
    // Check against targets
    if (latency > PERFORMANCE_TARGETS.latency.p99) {
      this.logger.warn('Latency exceeds target', {
        actual: latency,
        target: PERFORMANCE_TARGETS.latency.p99
      });
    }
  }

  /**
   * Handle opportunity execution error
   */
  private handleOpportunityError(opportunity: AlphaOpportunity, error: any): void {
    this.logger.error('Opportunity execution error', {
      id: opportunity.id,
      type: opportunity.type,
      error: error.message
    });
    
    // Remove from active
    this.activeOpportunities.delete(opportunity.id);
    
    // Update failure metrics
    this.performance.successRate = 
      this.executedCount / this.opportunityCount;
    
    this.emit('opportunity-error', { opportunity, error });
  }

  /**
   * Get current performance metrics
   */
  getPerformance(): AlphaPerformance {
    const uptime = Date.now() - this.startTime;
    
    return {
      ...this.performance,
      opportunitiesIdentified: this.opportunityCount,
      opportunitiesExecuted: this.executedCount,
      successRate: this.executedCount / Math.max(1, this.opportunityCount),
      totalPnL: this.totalPnL,
      hitRate: this.performance.successRate
    };
  }

  /**
   * Set orchestrator reference
   */
  setOrchestrator(orchestrator: SystemOrchestrator): void {
    this.orchestrator = orchestrator;
  }

  /**
   * Register with system orchestrator
   */
  private async registerWithOrchestrator(): Promise<void> {
    const registration = MessageFactory.create(
      MessageType.MODULE_REGISTER,
      'alpha-exploitation',
      'orchestrator',
      {
        moduleId: 'alpha-exploitation',
        moduleName: 'Alpha Exploitation Service',
        version: '1.0.0',
        capabilities: [
          'liquidity_aggregation',
          'arbitrage_detection',
          'microstructure_analysis',
          'market_defense',
          'advanced_analytics'
        ],
        dependencies: [
          'market-intel',
          'risk-engine',
          'execution-optimizer',
          'ai-core'
        ]
      }
    );
    
    await this.orchestrator!.sendMessage(registration);
  }

  /**
   * Initialize performance metrics
   */
  private initializePerformance(): AlphaPerformance {
    return {
      opportunitiesIdentified: 0,
      opportunitiesExecuted: 0,
      successRate: 0,
      totalPnL: new BigNumber(0),
      sharpeRatio: 0,
      maxDrawdown: 0,
      hitRate: 0,
      profitFactor: 0,
      averageReturn: 0,
      returnVolatility: 0,
      informationRatio: 0,
      calmarRatio: 0,
      executionMetrics: {
        avgSlippage: 0,
        avgLatency: 0,
        fillRate: 0,
        costSavings: 0
      }
    };
  }

  /**
   * Create logger instance
   */
  private createLogger(): Logger {
    // This would be properly configured in production
    return console as any;
  }

  /**
   * Initialize all components
   */
  private async initializeComponents(): Promise<void> {
    // Initialize liquidity aggregator
    this.liquidityAggregator = new SmartLiquidityAggregator(this.config);
    this.liquidityAggregator.on('liquidity-update', (update) => this.handleLiquidityUpdate(update));
    this.liquidityAggregator.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Initialize arbitrage engine
    this.arbitrageEngine = new ArbitrageEngine(this.config);
    this.arbitrageEngine.setLiquidityAggregator(this.liquidityAggregator);
    this.arbitrageEngine.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Initialize microstructure analyzer
    this.microstructureAnalyzer = new MicrostructureAnalyzer(this.config);
    this.microstructureAnalyzer.on('signal', (signal) => this.handleMicrostructureSignal(signal));
    this.microstructureAnalyzer.on('opportunity', (opp) => this.handleOpportunity(opp));
    
    // Initialize market defender
    this.marketDefender = new MarketDefender(this.config);
    this.marketDefender.on('threat', (threat) => this.handleThreat(threat));
    this.marketDefender.on('emergency-stop', (params) => this.handleEmergencyStop(params));
    this.marketDefender.on('reduce-exposure', (params) => this.handleReduceExposure(params));
    this.marketDefender.on('switch-venue', (params) => this.handleSwitchVenue(params));
    this.marketDefender.on('protection-enabled', (params) => this.handleProtectionEnabled(params));
    
    // Initialize market analytics
    this.marketAnalytics = new MarketAnalytics(this.config);
    this.marketAnalytics.on('insight', (insight) => this.handleInsight(insight));
    this.marketAnalytics.on('regime-change', (change) => this.handleRegimeChange(change));
    this.marketAnalytics.on('metrics-export', (metrics) => this.handleMetricsExport(metrics));
    
    // Register models with analytics
    this.marketAnalytics.registerModel('arbitrage_predictor');
    this.marketAnalytics.registerModel('microstructure_ml');
    this.marketAnalytics.registerModel('flow_classifier');
  }

  /**
   * Handle opportunity from any source
   */
  private async handleOpportunity(opportunity: AlphaOpportunity): Promise<void> {
    await this.processOpportunity(opportunity);
  }

  /**
   * Handle liquidity update
   */
  private handleLiquidityUpdate(update: any): void {
    // Forward to components that need liquidity data
    if (this.arbitrageEngine) {
      this.arbitrageEngine.updateMarketState(update);
    }
    if (this.microstructureAnalyzer) {
      this.microstructureAnalyzer.updateMarketState(update);
    }
  }

  /**
   * Handle emergency stop
   */
  private async handleEmergencyStop(params: any): Promise<void> {
    this.logger.error('EMERGENCY STOP TRIGGERED', params);
    
    // Stop all trading immediately
    this.emergencyStopActive = true;
    
    // Cancel all pending orders
    this.emit('cancel-all-orders', params);
    
    // Notify risk engine
    if (this.orchestrator) {
      await this.orchestrator.sendMessage(MessageFactory.create(
        MessageType.RISK_ALERT,
        'alpha-exploitation',
        'risk-engine',
        {
          type: 'EMERGENCY_STOP',
          reason: 'Manual trigger',
          timestamp: Date.now()
        }
      ));
    }
  }

  /**
   * Handle reduce exposure
   */
  private async handleReduceExposure(params: any): Promise<void> {
    this.logger.warn('Reducing exposure', params);
    
    // Notify risk engine to reduce position
    if (this.orchestrator) {
      await this.orchestrator.sendMessage(MessageFactory.create(
        MessageType.RISK_ALERT,
        'alpha-exploitation',
        'risk-engine',
        {
          type: 'REDUCE_EXPOSURE',
          symbol: params.symbol,
          reductionPercent: params.reductionPercent
        }
      ));
    }
  }

  /**
   * Handle switch venue
   */
  private handleSwitchVenue(params: any): void {
    this.logger.info('Switching venue', params);
    
    // Update preferred venues
    const venueIndex = this.config.venues.indexOf(params.currentVenue);
    if (venueIndex > -1) {
      this.config.venues.splice(venueIndex, 1);
    }
  }

  /**
   * Handle protection enabled
   */
  private handleProtectionEnabled(params: any): void {
    this.logger.info('Protection enabled', params);
    
    // Update local protection state
    this.emit('protection-enabled', params);
  }

  /**
   * Handle regime change
   */
  private handleRegimeChange(change: any): void {
    this.logger.info('Market regime changed', change);
    
    // Adjust strategies based on new regime
    this.adjustStrategiesForRegime(change.current);
    
    // Notify other components
    this.emit('regime-change', change);
  }

  /**
   * Handle metrics export
   */
  private handleMetricsExport(metrics: string): void {
    // In production, this would push to monitoring system
    this.emit('metrics', metrics);
  }

  /**
   * Adjust strategies for market regime
   */
  private adjustStrategiesForRegime(regime: string): void {
    switch (regime) {
      case 'high_volatility':
        // Widen spreads, reduce position sizes
        this.config.riskLimits.maxPositionSize = this.config.riskLimits.maxPositionSize.div(2);
        break;
        
      case 'low_liquidity':
        // Reduce order sizes, increase time horizons
        this.config.capitalAllocation.maxPerOpportunity = this.config.capitalAllocation.maxPerOpportunity.div(2);
        break;
        
      case 'risk_off':
        // Defensive mode
        this.config.minExpectedReturn *= 1.5;
        break;
        
      default:
        // Reset to normal parameters
        break;
    }
  }
} 