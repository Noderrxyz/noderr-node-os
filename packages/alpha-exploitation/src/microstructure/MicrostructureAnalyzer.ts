/**
 * MicrostructureAnalyzer - Elite market microstructure analysis
 * 
 * Features:
 * - Real-time order flow toxicity detection
 * - Hidden liquidity identification
 * - GARCH-based volatility and spread estimation
 * - Price discovery signals from LOB evolution
 * - Momentum ignition and manipulation detection
 * - Integration with AI Core for ML predictions
 */

import { EventEmitter } from 'events';
import { BigNumber } from 'bignumber.js';
import {
  AlphaExploitationConfig,
  MicrostructureSignal,
  MicrostructureSignalType,
  OrderFlowAnalysis,
  SpreadDynamics,
  MarketDepthProfile,
  VolumeDistribution,
  HiddenLiquidity,
  MarketImpactModel,
  MarketMicrostructure,
  AlphaOpportunity,
  AlphaType,
  AlphaSource,
  AlphaPriority
} from '@noderr/types';
import { MICROSTRUCTURE_CONFIG } from '@noderr/config/default';

interface OrderBookSnapshot {
  timestamp: number;
  venue: string;
  symbol: string;
  bids: Array<{ price: number; size: number; orders: number }>;
  asks: Array<{ price: number; size: number; orders: number }>;
  lastTrade?: {
    price: number;
    size: number;
    side: 'buy' | 'sell';
    timestamp: number;
  };
}

interface OrderFlowMetrics {
  buyVolume: BigNumber;
  sellVolume: BigNumber;
  buyOrderCount: number;
  sellOrderCount: number;
  largeOrderRatio: number;
  sweepCount: number;
  cancelRatio: number;
}

interface GARCHModel {
  omega: number;  // constant
  alpha: number;  // ARCH coefficient
  beta: number;   // GARCH coefficient
  lastVolatility: number;
  lastReturn: number;
}

export class MicrostructureAnalyzer extends EventEmitter {
  private config: AlphaExploitationConfig;
  private isRunning: boolean = false;
  
  // Data storage
  private orderBookHistory: Map<string, OrderBookSnapshot[]> = new Map();
  private orderFlowMetrics: Map<string, OrderFlowMetrics> = new Map();
  private priceHistory: Map<string, number[]> = new Map();
  private volatilityModels: Map<string, GARCHModel> = new Map();
  
  // Analysis state
  private microstructureProfiles: Map<string, MarketMicrostructure> = new Map();
  private hiddenLiquidityMap: Map<string, HiddenLiquidity[]> = new Map();
  private impactModels: Map<string, MarketImpactModel> = new Map();
  
  // Performance tracking
  private signalsGenerated: number = 0;
  private analysisLatency: number[] = [];
  
  // Analysis intervals
  private analysisInterval?: NodeJS.Timeout;
  private modelUpdateInterval?: NodeJS.Timeout;

  constructor(config: AlphaExploitationConfig) {
    super();
    this.config = config;
  }

  /**
   * Start the microstructure analyzer
   */
  async start(): Promise<void> {
    if (this.isRunning) return;
    
    this.isRunning = true;
    
    // Initialize GARCH models
    this.initializeVolatilityModels();
    
    // Start analysis loop
    this.analysisInterval = setInterval(
      () => this.analyzeMarketMicrostructure(),
      MICROSTRUCTURE_CONFIG.signals.momentumWindow / 10 // 500ms
    );
    
    // Update models periodically
    this.modelUpdateInterval = setInterval(
      () => this.updateModels(),
      60000 // 1 minute
    );
    
    this.emit('started');
  }

  /**
   * Stop the microstructure analyzer
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;
    
    this.isRunning = false;
    
    if (this.analysisInterval) {
      clearInterval(this.analysisInterval);
    }
    
    if (this.modelUpdateInterval) {
      clearInterval(this.modelUpdateInterval);
    }
    
    // Clear data
    this.orderBookHistory.clear();
    this.orderFlowMetrics.clear();
    
    this.emit('stopped');
  }

  /**
   * Update market state with new data
   */
  updateMarketState(marketState: any): void {
    const startTime = process.hrtime.bigint();
    
    // Process order book updates
    if (marketState.orderBook) {
      this.processOrderBookUpdate(marketState.orderBook);
    }
    
    // Process trades
    if (marketState.trades) {
      this.processTradeUpdates(marketState.trades);
    }
    
    // Update price history
    if (marketState.symbol && marketState.price) {
      this.updatePriceHistory(marketState.symbol, marketState.price);
    }
    
    const latency = Number(process.hrtime.bigint() - startTime) / 1e6;
    this.analysisLatency.push(latency);
  }

  /**
   * Main analysis loop
   */
  private async analyzeMarketMicrostructure(): Promise<void> {
    for (const [symbol, snapshots] of this.orderBookHistory) {
      if (snapshots.length < 2) continue;
      
      const latestSnapshot = snapshots[snapshots.length - 1];
      const analysis = this.performMicrostructureAnalysis(symbol, snapshots);
      
      if (analysis) {
        // Store microstructure profile
        this.microstructureProfiles.set(symbol, analysis);
        
        // Generate signals
        const signals = this.generateSignals(symbol, analysis);
        for (const signal of signals) {
          this.emit('signal', signal);
          this.signalsGenerated++;
        }
        
        // Check for opportunities
        const opportunity = this.checkForOpportunity(symbol, analysis, signals);
        if (opportunity) {
          this.emit('opportunity', opportunity);
        }
      }
    }
  }

  /**
   * Perform comprehensive microstructure analysis
   */
  private performMicrostructureAnalysis(
    symbol: string,
    snapshots: OrderBookSnapshot[]
  ): MarketMicrostructure | null {
    const latest = snapshots[snapshots.length - 1];
    if (!latest.bids.length || !latest.asks.length) return null;
    
    // Calculate spread dynamics
    const spreadDynamics = this.calculateSpreadDynamics(snapshots);
    
    // Analyze order flow
    const orderFlow = this.analyzeOrderFlow(symbol, snapshots);
    
    // Calculate market depth profile
    const depthProfile = this.calculateDepthProfile(latest);
    
    // Estimate liquidity metrics
    const liquidityMetrics = this.estimateLiquidity(latest, orderFlow);
    
    // Update GARCH volatility
    const volatility = this.updateGARCHVolatility(symbol);
    
    return {
      venue: latest.venue,
      symbol: latest.symbol,
      timestamp: latest.timestamp,
      spread: spreadDynamics,
      depth: depthProfile,
      orderFlow,
      liquidity: liquidityMetrics
    };
  }

  /**
   * Calculate spread dynamics
   */
  private calculateSpreadDynamics(snapshots: OrderBookSnapshot[]): SpreadDynamics {
    const spreads = snapshots.map(s => {
      if (!s.bids.length || !s.asks.length) return null;
      return s.asks[0].price - s.bids[0].price;
    }).filter(s => s !== null) as number[];
    
    if (spreads.length === 0) {
      return {
        absolute: 0,
        relative: 0,
        trend: 'stable'
      };
    }
    
    const current = spreads[spreads.length - 1];
    const average = spreads.reduce((a, b) => a + b, 0) / spreads.length;
    const midPrice = (snapshots[snapshots.length - 1].bids[0].price + 
                     snapshots[snapshots.length - 1].asks[0].price) / 2;
    
    // Detect trend
    let trend: 'widening' | 'narrowing' | 'stable' = 'stable';
    if (spreads.length > 10) {
      const recentAvg = spreads.slice(-5).reduce((a, b) => a + b, 0) / 5;
      const olderAvg = spreads.slice(-10, -5).reduce((a, b) => a + b, 0) / 5;
      
      if (recentAvg > olderAvg * 1.1) trend = 'widening';
      else if (recentAvg < olderAvg * 0.9) trend = 'narrowing';
    }
    
    return {
      absolute: current,
      relative: (current / midPrice) * 10000, // basis points
      trend
    };
  }

  /**
   * Analyze order flow
   */
  private analyzeOrderFlow(
    symbol: string,
    snapshots: OrderBookSnapshot[]
  ): OrderFlowAnalysis {
    const metrics = this.orderFlowMetrics.get(symbol) || {
      buyVolume: new BigNumber(0),
      sellVolume: new BigNumber(0),
      buyOrderCount: 0,
      sellOrderCount: 0,
      largeOrderRatio: 0,
      sweepCount: 0,
      cancelRatio: 0
    };
    
    // Detect order flow imbalance
    const imbalance = this.detectOrderImbalance(snapshots);
    
    // Classify flow
    const classification = this.classifyOrderFlow(metrics);
    
    // Calculate toxicity
    const toxicity = this.calculateToxicity(metrics);
    
    return {
      venue: snapshots[0].venue,
      symbol: snapshots[0].symbol,
      period: snapshots[snapshots.length - 1].timestamp - snapshots[0].timestamp,
      metrics: {
        buyPressure: metrics.buyVolume.div(metrics.buyVolume.plus(metrics.sellVolume)).toNumber(),
        sellPressure: metrics.sellVolume.div(metrics.buyVolume.plus(metrics.sellVolume)).toNumber(),
        largeOrderRatio: metrics.largeOrderRatio,
        oddLotRatio: 1 - metrics.largeOrderRatio,
        sweepRatio: metrics.sweepCount / Math.max(1, metrics.buyOrderCount + metrics.sellOrderCount)
      },
      classification,
      toxicity: {
        score: toxicity,
        components: {
          adverseSelection: toxicity * 0.4,
          inventoryRisk: toxicity * 0.3,
          informationAsymmetry: toxicity * 0.3
        }
      }
    };
  }

  /**
   * Calculate market depth profile
   */
  private calculateDepthProfile(snapshot: OrderBookSnapshot): MarketDepthProfile {
    const bidVolume = snapshot.bids.reduce((sum, level) => sum.plus(level.size), new BigNumber(0));
    const askVolume = snapshot.asks.reduce((sum, level) => sum.plus(level.size), new BigNumber(0));
    
    // Calculate imbalance
    const totalVolume = bidVolume.plus(askVolume);
    const imbalanceRatio = totalVolume.gt(0) 
      ? bidVolume.minus(askVolume).div(totalVolume).toNumber()
      : 0;
    
    // Volume distribution
    const allLevels = [...snapshot.bids, ...snapshot.asks];
    const sizes = allLevels.map(l => l.size).sort((a, b) => a - b);
    
    const distribution: VolumeDistribution = {
      percentiles: {
        p10: sizes[Math.floor(sizes.length * 0.1)],
        p25: sizes[Math.floor(sizes.length * 0.25)],
        p50: sizes[Math.floor(sizes.length * 0.5)],
        p75: sizes[Math.floor(sizes.length * 0.75)],
        p90: sizes[Math.floor(sizes.length * 0.9)],
        p95: sizes[Math.floor(sizes.length * 0.95)],
        p99: sizes[Math.floor(sizes.length * 0.99)]
      },
      skewness: this.calculateSkewness(sizes),
      kurtosis: this.calculateKurtosis(sizes),
      gini: this.calculateGini(sizes)
    };
    
    return {
      venue: snapshot.venue,
      symbol: snapshot.symbol,
      timestamp: snapshot.timestamp,
      levels: Math.max(snapshot.bids.length, snapshot.asks.length),
      profile: {
        totalBidVolume: bidVolume,
        totalAskVolume: askVolume,
        imbalanceRatio,
        volumeDistribution: distribution,
        priceElasticity: this.calculatePriceElasticity(snapshot)
      },
      dynamics: {
        replenishmentRate: 0.8, // Placeholder
        decayRate: 0.2,
        shiftVelocity: 0.1
      }
    };
  }

  /**
   * Generate microstructure signals
   */
  private generateSignals(
    symbol: string,
    microstructure: MarketMicrostructure
  ): MicrostructureSignal[] {
    const signals: MicrostructureSignal[] = [];
    
    // Order imbalance signal
    if (Math.abs(microstructure.depth.imbalance) > MICROSTRUCTURE_CONFIG.signals.imbalanceThreshold) {
      signals.push({
        venue: microstructure.venue,
        symbol,
        timestamp: Date.now(),
        type: MicrostructureSignalType.ORDER_FLOW_IMBALANCE,
        strength: microstructure.depth.imbalance,
        confidence: Math.min(0.9, Math.abs(microstructure.depth.imbalance)),
        metadata: {
          orderImbalance: microstructure.depth.imbalance,
          direction: microstructure.depth.imbalance > 0 ? 'buy' : 'sell'
        }
      });
    }
    
    // Toxic flow detection
    if (microstructure.orderFlow.toxicity > MICROSTRUCTURE_CONFIG.orderflow.toxicityThreshold) {
      signals.push({
        venue: microstructure.venue,
        symbol,
        timestamp: Date.now(),
        type: MicrostructureSignalType.TOXIC_FLOW,
        strength: -microstructure.orderFlow.toxicity,
        confidence: microstructure.orderFlow.toxicity,
        metadata: {
          orderFlowToxicity: microstructure.orderFlow.toxicity,
          recommendation: 'reduce_exposure'
        }
      });
    }
    
    // Spread dynamics signal
    if (microstructure.spread.trend === 'widening' && microstructure.spread.relative > 20) {
      signals.push({
        venue: microstructure.venue,
        symbol,
        timestamp: Date.now(),
        type: MicrostructureSignalType.INVENTORY_PRESSURE,
        strength: -0.5,
        confidence: 0.7,
        metadata: {
          spreadDynamics: microstructure.spread,
          action: 'widen_quotes'
        }
      });
    }
    
    // Hidden liquidity detection
    const hiddenLiq = this.detectHiddenLiquidity(symbol, microstructure);
    if (hiddenLiq) {
      signals.push({
        venue: microstructure.venue,
        symbol,
        timestamp: Date.now(),
        type: MicrostructureSignalType.HIDDEN_LIQUIDITY,
        strength: 0.6,
        confidence: hiddenLiq.confidence,
        metadata: {
          hiddenSize: hiddenLiq.estimatedSize.toString(),
          priceLevel: hiddenLiq.priceLevel,
          type: hiddenLiq.type
        }
      });
    }
    
    return signals;
  }

  /**
   * Check for microstructure-based opportunities
   */
  private checkForOpportunity(
    symbol: string,
    microstructure: MarketMicrostructure,
    signals: MicrostructureSignal[]
  ): AlphaOpportunity | null {
    // Strong order imbalance opportunity
    const imbalanceSignal = signals.find(s => s.type === MicrostructureSignalType.ORDER_FLOW_IMBALANCE);
    if (imbalanceSignal && Math.abs(imbalanceSignal.strength) > 0.7) {
      const direction = imbalanceSignal.strength > 0 ? 'buy' : 'sell';
      const expectedMove = Math.abs(imbalanceSignal.strength) * 10; // basis points
      
      return {
        id: `micro_imb_${symbol}_${Date.now()}`,
        type: AlphaType.MICROSTRUCTURE,
        source: AlphaSource.ORDERBOOK_IMBALANCE,
        confidence: imbalanceSignal.confidence,
        expectedReturn: expectedMove,
        riskScore: 0.25,
        timeHorizon: 5000, // 5 seconds
        timeWindow: 5000,
        capital: new BigNumber(25000),
        priority: AlphaPriority.HIGH,
        timestamp: Date.now(),
        metadata: {
          signal: 'order_imbalance',
          direction,
          imbalance: imbalanceSignal.strength,
          microstructure
        }
      };
    }
    
    // Hidden liquidity opportunity
    const hiddenSignal = signals.find(s => s.type === MicrostructureSignalType.HIDDEN_LIQUIDITY);
    if (hiddenSignal && hiddenSignal.confidence > 0.8) {
      return {
        id: `micro_hidden_${symbol}_${Date.now()}`,
        type: AlphaType.MICROSTRUCTURE,
        source: AlphaSource.MICROSTRUCTURE_SIGNAL,
        confidence: hiddenSignal.confidence,
        expectedReturn: 15, // 15 basis points for liquidity provision
        riskScore: 0.2,
        timeHorizon: 30000, // 30 seconds
        timeWindow: 30000,
        capital: new BigNumber(50000),
        priority: AlphaPriority.NORMAL,
        timestamp: Date.now(),
        metadata: {
          signal: 'hidden_liquidity',
          ...hiddenSignal.metadata
        }
      };
    }
    
    return null;
  }

  /**
   * Detect hidden liquidity (iceberg orders, etc.)
   */
  private detectHiddenLiquidity(
    symbol: string,
    microstructure: MarketMicrostructure
  ): HiddenLiquidity | null {
    const history = this.orderBookHistory.get(symbol);
    if (!history || history.length < 10) return null;
    
    // Look for consistent refilling at specific price levels
    const priceRefills: Map<number, number> = new Map();
    
    for (let i = 1; i < history.length; i++) {
      const prev = history[i - 1];
      const curr = history[i];
      
      // Check bid side
      for (const currBid of curr.bids) {
        const prevBid = prev.bids.find(b => b.price === currBid.price);
        if (prevBid && currBid.size > prevBid.size * 0.9 && prevBid.size < currBid.size) {
          priceRefills.set(currBid.price, (priceRefills.get(currBid.price) || 0) + 1);
        }
      }
      
      // Check ask side
      for (const currAsk of curr.asks) {
        const prevAsk = prev.asks.find(a => a.price === currAsk.price);
        if (prevAsk && currAsk.size > prevAsk.size * 0.9 && prevAsk.size < currAsk.size) {
          priceRefills.set(currAsk.price, (priceRefills.get(currAsk.price) || 0) + 1);
        }
      }
    }
    
    // Find most refilled level
    let maxRefills = 0;
    let suspiciousPrice = 0;
    
    for (const [price, refills] of priceRefills) {
      if (refills > maxRefills) {
        maxRefills = refills;
        suspiciousPrice = price;
      }
    }
    
    if (maxRefills >= 3) { // At least 3 refills detected
      return {
        venue: microstructure.venue,
        symbol,
        detected: true,
        confidence: Math.min(0.9, maxRefills / 10),
        estimatedSize: new BigNumber(100000), // Placeholder
        priceLevel: suspiciousPrice,
        type: 'iceberg',
        behavior: {
          refillRate: maxRefills / history.length,
          triggerSize: new BigNumber(10000),
          participation: 0.3
        }
      };
    }
    
    return null;
  }

  /**
   * Calculate order flow toxicity
   */
  private calculateToxicity(metrics: OrderFlowMetrics): number {
    // Simple toxicity model based on:
    // 1. Order cancellation ratio
    // 2. Large order ratio (potential informed trading)
    // 3. Sweep frequency
    
    let toxicity = 0;
    
    // High cancellation = potential manipulation
    toxicity += metrics.cancelRatio * 0.3;
    
    // Many large orders = potential informed trading
    toxicity += metrics.largeOrderRatio * 0.4;
    
    // Frequent sweeps = aggressive taking
    const totalOrders = metrics.buyOrderCount + metrics.sellOrderCount;
    const sweepRatio = totalOrders > 0 ? metrics.sweepCount / totalOrders : 0;
    toxicity += sweepRatio * 0.3;
    
    return Math.min(1, toxicity);
  }

  /**
   * Detect order imbalance
   */
  private detectOrderImbalance(snapshots: OrderBookSnapshot[]): number {
    if (snapshots.length < 2) return 0;
    
    const latest = snapshots[snapshots.length - 1];
    const totalBidSize = latest.bids.reduce((sum, b) => sum + b.size, 0);
    const totalAskSize = latest.asks.reduce((sum, a) => sum + a.size, 0);
    
    const total = totalBidSize + totalAskSize;
    if (total === 0) return 0;
    
    return (totalBidSize - totalAskSize) / total;
  }

  /**
   * Classify order flow
   */
  private classifyOrderFlow(metrics: OrderFlowMetrics): Record<string, number> {
    const total = metrics.buyVolume.plus(metrics.sellVolume);
    if (total.eq(0)) {
      return { retail: 0.25, institutional: 0.25, algorithmic: 0.25, highFrequency: 0.25 };
    }
    
    // Simple classification based on order characteristics
    let retail = 0.2;
    let institutional = 0.2;
    let algorithmic = 0.3;
    let highFrequency = 0.3;
    
    // Large orders suggest institutional
    if (metrics.largeOrderRatio > 0.3) {
      institutional += 0.2;
      retail -= 0.1;
    }
    
    // High cancel ratio suggests HFT
    if (metrics.cancelRatio > 0.5) {
      highFrequency += 0.2;
      retail -= 0.1;
    }
    
    // Normalize
    const sum = retail + institutional + algorithmic + highFrequency;
    
    return {
      retail: retail / sum,
      institutional: institutional / sum,
      algorithmic: algorithmic / sum,
      highFrequency: highFrequency / sum
    };
  }

  /**
   * Estimate liquidity metrics
   */
  private estimateLiquidity(
    snapshot: OrderBookSnapshot,
    orderFlow: OrderFlowAnalysis
  ): MarketMicrostructure['liquidity'] {
    const bidLiquidity = snapshot.bids.reduce((sum, b) => sum + b.size * b.price, 0);
    const askLiquidity = snapshot.asks.reduce((sum, a) => sum + a.size * a.price, 0);
    
    return {
      available: new BigNumber(bidLiquidity + askLiquidity),
      resilience: 1 - orderFlow.toxicity.score, // Inverse of toxicity
      replenishmentRate: 0.5 // orders per second (placeholder)
    };
  }

  /**
   * Calculate VWAP
   */
  private calculateVWAP(snapshots: OrderBookSnapshot[]): number {
    let volumeSum = 0;
    let priceVolumeSum = 0;
    
    for (const snapshot of snapshots) {
      if (snapshot.lastTrade) {
        const volume = snapshot.lastTrade.size;
        const price = snapshot.lastTrade.price;
        
        volumeSum += volume;
        priceVolumeSum += price * volume;
      }
    }
    
    return volumeSum > 0 ? priceVolumeSum / volumeSum : 0;
  }

  /**
   * Update GARCH volatility model
   */
  private updateGARCHVolatility(symbol: string): number {
    const prices = this.priceHistory.get(symbol);
    if (!prices || prices.length < 2) return 0;
    
    let model = this.volatilityModels.get(symbol);
    if (!model) {
      // Initialize with default parameters
      model = {
        omega: 0.000001,
        alpha: 0.1,
        beta: 0.85,
        lastVolatility: 0.02,
        lastReturn: 0
      };
      this.volatilityModels.set(symbol, model);
    }
    
    // Calculate return
    const currentPrice = prices[prices.length - 1];
    const prevPrice = prices[prices.length - 2];
    const return_ = Math.log(currentPrice / prevPrice);
    
    // GARCH(1,1) update
    const residual = return_ - model.lastReturn;
    const variance = model.omega + 
                    model.alpha * Math.pow(residual, 2) + 
                    model.beta * Math.pow(model.lastVolatility, 2);
    
    model.lastVolatility = Math.sqrt(variance);
    model.lastReturn = return_;
    
    return model.lastVolatility;
  }

  /**
   * Calculate price elasticity
   */
  private calculatePriceElasticity(snapshot: OrderBookSnapshot): number {
    // Simplified elasticity calculation
    if (snapshot.bids.length < 2 || snapshot.asks.length < 2) return 1;
    
    const bidElasticity = (snapshot.bids[0].size - snapshot.bids[1].size) / 
                         (snapshot.bids[0].price - snapshot.bids[1].price);
    
    const askElasticity = (snapshot.asks[1].size - snapshot.asks[0].size) / 
                         (snapshot.asks[1].price - snapshot.asks[0].price);
    
    return (Math.abs(bidElasticity) + Math.abs(askElasticity)) / 2;
  }

  /**
   * Calculate statistical moments
   */
  private calculateSkewness(data: number[]): number {
    const n = data.length;
    if (n < 3) return 0;
    
    const mean = data.reduce((a, b) => a + b, 0) / n;
    const m3 = data.reduce((sum, x) => sum + Math.pow(x - mean, 3), 0) / n;
    const m2 = data.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / n;
    
    return m3 / Math.pow(m2, 1.5);
  }

  private calculateKurtosis(data: number[]): number {
    const n = data.length;
    if (n < 4) return 0;
    
    const mean = data.reduce((a, b) => a + b, 0) / n;
    const m4 = data.reduce((sum, x) => sum + Math.pow(x - mean, 4), 0) / n;
    const m2 = data.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / n;
    
    return m4 / Math.pow(m2, 2) - 3;
  }

  private calculateGini(data: number[]): number {
    // Gini coefficient for concentration
    const sorted = [...data].sort((a, b) => a - b);
    const n = sorted.length;
    const sum = sorted.reduce((a, b) => a + b, 0);
    
    if (sum === 0) return 0;
    
    let gini = 0;
    for (let i = 0; i < n; i++) {
      gini += (2 * (i + 1) - n - 1) * sorted[i];
    }
    
    return gini / (n * sum);
  }

  /**
   * Process order book update
   */
  private processOrderBookUpdate(orderBook: any): void {
    const { symbol, venue, bids, asks, timestamp } = orderBook;
    
    const snapshot: OrderBookSnapshot = {
      timestamp: timestamp || Date.now(),
      venue,
      symbol,
      bids: bids.map((b: any) => ({
        price: b[0],
        size: b[1],
        orders: b[2] || 1
      })),
      asks: asks.map((a: any) => ({
        price: a[0],
        size: a[1],
        orders: a[2] || 1
      }))
    };
    
    // Store snapshot
    if (!this.orderBookHistory.has(symbol)) {
      this.orderBookHistory.set(symbol, []);
    }
    
    const history = this.orderBookHistory.get(symbol)!;
    history.push(snapshot);
    
    // Keep last 100 snapshots
    if (history.length > 100) {
      history.shift();
    }
  }

  /**
   * Process trade updates
   */
  private processTradeUpdates(trades: any[]): void {
    for (const trade of trades) {
      const { symbol, price, size, side, timestamp } = trade;
      
      // Update order flow metrics
      if (!this.orderFlowMetrics.has(symbol)) {
        this.orderFlowMetrics.set(symbol, {
          buyVolume: new BigNumber(0),
          sellVolume: new BigNumber(0),
          buyOrderCount: 0,
          sellOrderCount: 0,
          largeOrderRatio: 0,
          sweepCount: 0,
          cancelRatio: 0
        });
      }
      
      const metrics = this.orderFlowMetrics.get(symbol)!;
      
      if (side === 'buy') {
        metrics.buyVolume = metrics.buyVolume.plus(size);
        metrics.buyOrderCount++;
      } else {
        metrics.sellVolume = metrics.sellVolume.plus(size);
        metrics.sellOrderCount++;
      }
      
      // Update large order ratio
      if (size > 10000) { // $10k+ is "large"
        const totalOrders = metrics.buyOrderCount + metrics.sellOrderCount;
        metrics.largeOrderRatio = (metrics.largeOrderRatio * (totalOrders - 1) + 1) / totalOrders;
      }
      
      // Detect sweeps (simplified)
      if (size > 50000) { // $50k+ might be a sweep
        metrics.sweepCount++;
      }
    }
  }

  /**
   * Update price history
   */
  private updatePriceHistory(symbol: string, price: number): void {
    if (!this.priceHistory.has(symbol)) {
      this.priceHistory.set(symbol, []);
    }
    
    const history = this.priceHistory.get(symbol)!;
    history.push(price);
    
    // Keep last 1000 prices
    if (history.length > 1000) {
      history.shift();
    }
  }

  /**
   * Initialize volatility models
   */
  private initializeVolatilityModels(): void {
    // Models will be initialized on first use
  }

  /**
   * Update models periodically
   */
  private updateModels(): void {
    // Update impact models based on recent data
    for (const [symbol, history] of this.orderBookHistory) {
      if (history.length < 20) continue;
      
      const impactModel = this.estimateMarketImpact(symbol, history);
      if (impactModel) {
        this.impactModels.set(symbol, impactModel);
      }
    }
  }

  /**
   * Estimate market impact model
   */
  private estimateMarketImpact(
    symbol: string,
    history: OrderBookSnapshot[]
  ): MarketImpactModel | null {
    // Simplified impact model
    return {
      venue: history[0].venue,
      symbol,
      temporary: {
        linear: 0.0001,
        squareRoot: 0.001,
        parameters: {
          lambda: 0.1,
          eta: 0.01,
          gamma: 0.001
        }
      },
      permanent: {
        linear: 0.00005,
        concave: 0.0005,
        parameters: {
          alpha: 0.05,
          beta: 0.5
        }
      },
      decay: {
        halfLife: 300000, // 5 minutes
        shape: 'exponential'
      }
    };
  }

  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    const avgLatency = this.analysisLatency.length > 0
      ? this.analysisLatency.reduce((a, b) => a + b, 0) / this.analysisLatency.length
      : 0;
    
    return {
      signalsGenerated: this.signalsGenerated,
      avgAnalysisLatency: avgLatency,
      symbolsAnalyzed: this.orderBookHistory.size,
      modelsActive: this.volatilityModels.size
    };
  }
} 