/**
 * MarketAnalytics - Real-time statistical summary generation and insights
 * 
 * Features:
 * - Real-time statistical summary generation
 * - Rolling metrics for slippage, alpha decay, latency
 * - Model evaluation hooks for live ML models
 * - Prometheus metrics export support
 * - Market regime detection and flow analysis
 * - Integration with dashboards
 */

import { EventEmitter } from 'events';
import { BigNumber } from 'bignumber.js';
import {
  AlphaExploitationConfig,
  MarketInsight,
  InsightType,
  InsightPriority,
  MarketRegime,
  VolumeProfile,
  FlowAnalysis,
  PerformanceMetrics,
  ModelPerformance,
  RegimeAnalysis,
  CorrelationMatrix
} from '@noderr/types';
import { ANALYTICS_CONFIG } from '@noderr/config/default';

interface RollingMetric {
  name: string;
  values: number[];
  timestamps: number[];
  windowSize: number;
  current: number;
  mean: number;
  std: number;
  percentiles: {
    p10: number;
    p50: number;
    p90: number;
    p95: number;
    p99: number;
  };
}

interface ModelEvaluation {
  modelId: string;
  predictions: number[];
  actuals: number[];
  timestamps: number[];
  metrics: {
    mse: number;
    mae: number;
    sharpe: number;
    hitRate: number;
    maxDrawdown: number;
  };
}

interface PrometheusMetric {
  name: string;
  type: 'counter' | 'gauge' | 'histogram';
  value: number;
  labels: Record<string, string>;
  timestamp: number;
}

export class MarketAnalytics extends EventEmitter {
  private config: AlphaExploitationConfig;
  private isRunning: boolean = false;
  
  // Metrics storage
  private rollingMetrics: Map<string, RollingMetric> = new Map();
  private modelEvaluations: Map<string, ModelEvaluation> = new Map();
  private prometheusMetrics: Map<string, PrometheusMetric> = new Map();
  
  // Market analysis
  private currentRegime: MarketRegime = MarketRegime.NORMAL;
  private volumeProfiles: Map<string, VolumeProfile> = new Map();
  private flowAnalysis: Map<string, FlowAnalysis> = new Map();
  private correlationMatrices: Map<string, CorrelationMatrix> = new Map();
  
  // Performance tracking
  private performanceMetrics: PerformanceMetrics;
  private insightsGenerated: number = 0;
  
  // Analysis intervals
  private metricsInterval?: NodeJS.Timeout;
  private regimeInterval?: NodeJS.Timeout;
  private exportInterval?: NodeJS.Timeout;

  constructor(config: AlphaExploitationConfig) {
    super();
    this.config = config;
    
    // Initialize performance metrics
    this.performanceMetrics = {
      pnl: BigInt(0),
      sharpeRatio: 0,
      strategyId: 'market-analytics',
      totalOpportunities: 0,
      successfulTrades: 0,
      totalPnL: 0,
      maxDrawdown: 0,
      winRate: 0,
      avgSlippage: 0,
      avgLatency: 0,
      uptime: 0,
      startTime: Date.now()
    };
    
    // Initialize core metrics
    this.initializeMetrics();
  }

  /**
   * Start the market analytics engine
   */
  async start(): Promise<void> {
    if (this.isRunning) return;
    
    this.isRunning = true;
    
    // Start metrics collection
    this.metricsInterval = setInterval(
      () => this.updateMetrics(),
      ANALYTICS_CONFIG.metrics.updateInterval
    );
    
    // Start regime detection
    this.regimeInterval = setInterval(
      () => this.detectRegimeChange(),
      ANALYTICS_CONFIG.regime.detectionInterval
    );
    
    // Start Prometheus export
    this.exportInterval = setInterval(
      () => this.exportPrometheusMetrics(),
      ANALYTICS_CONFIG.export.prometheusInterval
    );
    
    this.emit('started');
  }

  /**
   * Stop the market analytics engine
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;
    
    this.isRunning = false;
    
    if (this.metricsInterval) {
      clearInterval(this.metricsInterval);
    }
    
    if (this.regimeInterval) {
      clearInterval(this.regimeInterval);
    }
    
    if (this.exportInterval) {
      clearInterval(this.exportInterval);
    }
    
    this.emit('stopped');
  }

  /**
   * Update analytics with new trade data
   */
  updateTrade(trade: any): void {
    // Update performance metrics
    this.performanceMetrics.totalOpportunities = (this.performanceMetrics.totalOpportunities || 0) + 1;
    
    if (trade.pnl > 0) {
      this.performanceMetrics.successfulTrades = (this.performanceMetrics.successfulTrades || 0) + 1;
    }
    
    this.performanceMetrics.totalPnL = (this.performanceMetrics.totalPnL || 0) + (trade.pnl || 0);
    
    // Update rolling metrics
    this.updateRollingMetric('slippage', trade.slippage || 0);
    this.updateRollingMetric('latency', trade.latency || 0);
    this.updateRollingMetric('pnl', trade.pnl || 0);
    
    // Update win rate
    this.performanceMetrics.winRate = (this.performanceMetrics.successfulTrades || 0) / 
                                      Math.max(1, this.performanceMetrics.totalOpportunities || 0);
    
    // Generate insights if needed
    this.checkForInsights(trade);
  }

  /**
   * Update market state for analytics
   */
  updateMarketState(marketState: any): void {
    // Update volume profile
    if (marketState.symbol && marketState.volume) {
      this.updateVolumeProfile(marketState.symbol, marketState.volume);
    }
    
    // Update flow analysis
    if (marketState.flows) {
      this.updateFlowAnalysis(marketState.symbol, marketState.flows);
    }
    
    // Update correlations
    if (marketState.prices) {
      this.updateCorrelations(marketState.prices);
    }
  }

  /**
   * Register a model for evaluation
   */
  registerModel(modelId: string): void {
    this.modelEvaluations.set(modelId, {
      modelId,
      predictions: [],
      actuals: [],
      timestamps: [],
      metrics: {
        mse: 0,
        mae: 0,
        sharpe: 0,
        hitRate: 0,
        maxDrawdown: 0
      }
    });
  }

  /**
   * Update model prediction and actual
   */
  updateModelPrediction(modelId: string, prediction: number, actual: number): void {
    const evaluation = this.modelEvaluations.get(modelId);
    if (!evaluation) return;
    
    evaluation.predictions.push(prediction);
    evaluation.actuals.push(actual);
    evaluation.timestamps.push(Date.now());
    
    // Keep last 1000 predictions
    if (evaluation.predictions.length > 1000) {
      evaluation.predictions.shift();
      evaluation.actuals.shift();
      evaluation.timestamps.shift();
    }
    
    // Update metrics
    this.updateModelMetrics(evaluation);
  }

  /**
   * Get current market state
   */
  async getMarketState(): Promise<any> {
    return {
      regime: this.currentRegime,
      volumeProfiles: Array.from(this.volumeProfiles.values()),
      flowAnalysis: Array.from(this.flowAnalysis.values()),
      correlations: Array.from(this.correlationMatrices.values()),
      performance: this.performanceMetrics,
      insights: this.getRecentInsights()
    };
  }

  /**
   * Get performance metrics
   */
  getPerformanceMetrics(): PerformanceMetrics {
    // Update uptime
    this.performanceMetrics.uptime = Date.now() - (this.performanceMetrics.startTime || Date.now());
    
    // Calculate Sharpe ratio
    const pnlMetric = this.rollingMetrics.get('pnl');
    if (pnlMetric && pnlMetric.std > 0) {
      this.performanceMetrics.sharpeRatio = (pnlMetric.mean * 252) / (pnlMetric.std * Math.sqrt(252));
    }
    
    // Update average metrics
    const slippageMetric = this.rollingMetrics.get('slippage');
    if (slippageMetric) {
      this.performanceMetrics.avgSlippage = slippageMetric.mean;
    }
    
    const latencyMetric = this.rollingMetrics.get('latency');
    if (latencyMetric) {
      this.performanceMetrics.avgLatency = latencyMetric.mean;
    }
    
    return this.performanceMetrics;
  }

  /**
   * Get model performance
   */
  getModelPerformance(modelId: string): ModelPerformance | null {
    const evaluation = this.modelEvaluations.get(modelId);
    if (!evaluation) return null;
    
    return {
      modelId,
      mae: evaluation.metrics.mae,
      rmse: evaluation.metrics.mae, // Using mae as rmse placeholder
      sharpe: evaluation.metrics.sharpe,
      accuracy: evaluation.metrics.hitRate,
      lastUpdated: evaluation.timestamps[evaluation.timestamps.length - 1] || 0
    };
  }

  /**
   * Get Prometheus metrics
   */
  getPrometheusMetrics(): string {
    let output = '';
    
    for (const [name, metric] of this.prometheusMetrics) {
      const labels = Object.entries(metric.labels)
        .map(([k, v]) => `${k}="${v}"`)
        .join(',');
      
      output += `# TYPE ${metric.name} ${metric.type}\n`;
      output += `${metric.name}{${labels}} ${metric.value} ${metric.timestamp}\n`;
    }
    
    return output;
  }

  /**
   * Initialize core metrics
   */
  private initializeMetrics(): void {
    // Initialize rolling metrics
    this.createRollingMetric('slippage', ANALYTICS_CONFIG.metrics.rollingWindow);
    this.createRollingMetric('latency', ANALYTICS_CONFIG.metrics.rollingWindow);
    this.createRollingMetric('pnl', ANALYTICS_CONFIG.metrics.rollingWindow);
    this.createRollingMetric('volume', ANALYTICS_CONFIG.metrics.rollingWindow);
    this.createRollingMetric('spread', ANALYTICS_CONFIG.metrics.rollingWindow);
    
    // Initialize Prometheus metrics
    this.createPrometheusMetric('noderr_opportunities_total', 'counter', 0);
    this.createPrometheusMetric('noderr_trades_successful', 'counter', 0);
    this.createPrometheusMetric('noderr_pnl_total', 'gauge', 0);
    this.createPrometheusMetric('noderr_sharpe_ratio', 'gauge', 0);
    this.createPrometheusMetric('noderr_win_rate', 'gauge', 0);
    this.createPrometheusMetric('noderr_avg_slippage_bps', 'gauge', 0);
    this.createPrometheusMetric('noderr_avg_latency_ms', 'gauge', 0);
    this.createPrometheusMetric('noderr_regime', 'gauge', 0);
  }

  /**
   * Create a rolling metric
   */
  private createRollingMetric(name: string, windowSize: number): void {
    this.rollingMetrics.set(name, {
      name,
      values: [],
      timestamps: [],
      windowSize,
      current: 0,
      mean: 0,
      std: 0,
      percentiles: {
        p10: 0,
        p50: 0,
        p90: 0,
        p95: 0,
        p99: 0
      }
    });
  }

  /**
   * Update a rolling metric
   */
  private updateRollingMetric(name: string, value: number): void {
    const metric = this.rollingMetrics.get(name);
    if (!metric) return;
    
    metric.values.push(value);
    metric.timestamps.push(Date.now());
    metric.current = value;
    
    // Maintain window size
    const cutoff = Date.now() - metric.windowSize;
    while (metric.timestamps.length > 0 && metric.timestamps[0] < cutoff) {
      metric.values.shift();
      metric.timestamps.shift();
    }
    
    // Update statistics
    if (metric.values.length > 0) {
      metric.mean = metric.values.reduce((a, b) => a + b, 0) / metric.values.length;
      
      const variance = metric.values.reduce((sum, val) => 
        sum + Math.pow(val - metric.mean, 2), 0) / metric.values.length;
      metric.std = Math.sqrt(variance);
      
      // Calculate percentiles
      const sorted = [...metric.values].sort((a, b) => a - b);
      metric.percentiles = {
        p10: sorted[Math.floor(sorted.length * 0.1)],
        p50: sorted[Math.floor(sorted.length * 0.5)],
        p90: sorted[Math.floor(sorted.length * 0.9)],
        p95: sorted[Math.floor(sorted.length * 0.95)],
        p99: sorted[Math.floor(sorted.length * 0.99)]
      };
    }
  }

  /**
   * Create a Prometheus metric
   */
  private createPrometheusMetric(
    name: string, 
    type: 'counter' | 'gauge' | 'histogram',
    value: number
  ): void {
    this.prometheusMetrics.set(name, {
      name,
      type,
      value,
      labels: {
        instance: 'noderr_alpha',
        environment: process.env.NODE_ENV || 'production'
      },
      timestamp: Date.now()
    });
  }

  /**
   * Update metrics periodically
   */
  private updateMetrics(): void {
    // Update Prometheus metrics
    this.updatePrometheusMetric('noderr_opportunities_total', this.performanceMetrics.totalOpportunities || 0);
    this.updatePrometheusMetric('noderr_trades_successful', this.performanceMetrics.successfulTrades || 0);
    this.updatePrometheusMetric('noderr_pnl_total', this.performanceMetrics.totalPnL || 0);
    this.updatePrometheusMetric('noderr_sharpe_ratio', this.performanceMetrics.sharpeRatio);
    this.updatePrometheusMetric('noderr_win_rate', this.performanceMetrics.winRate || 0);
    this.updatePrometheusMetric('noderr_avg_slippage_bps', (this.performanceMetrics.avgSlippage || 0) * 10000);
    this.updatePrometheusMetric('noderr_avg_latency_ms', this.performanceMetrics.avgLatency || 0);
    this.updatePrometheusMetric('noderr_regime', this.regimeToNumber(this.currentRegime));
    
    // Calculate max drawdown
    this.updateMaxDrawdown();
  }

  /**
   * Update a Prometheus metric
   */
  private updatePrometheusMetric(name: string, value: number): void {
    const metric = this.prometheusMetrics.get(name);
    if (metric) {
      metric.value = value;
      metric.timestamp = Date.now();
    }
  }

  /**
   * Detect market regime changes
   */
  private async detectRegimeChange(): Promise<void> {
    const volumeMetric = this.rollingMetrics.get('volume');
    const spreadMetric = this.rollingMetrics.get('spread');
    
    if (!volumeMetric || !spreadMetric) return;
    
    let newRegime = MarketRegime.NORMAL;
    
    // High volatility detection
    if (spreadMetric.current > spreadMetric.percentiles.p90) {
      newRegime = MarketRegime.HIGH_VOLATILITY;
    }
    
    // Low liquidity detection
    else if (volumeMetric.current < volumeMetric.percentiles.p10) {
      newRegime = MarketRegime.LOW_LIQUIDITY;
    }
    
    // Trending detection (simplified)
    const pnlMetric = this.rollingMetrics.get('pnl');
    if (pnlMetric && pnlMetric.values.length > 10) {
      const recentTrend = this.calculateTrend(pnlMetric.values.slice(-10));
      if (Math.abs(recentTrend) > 0.5) {
        newRegime = MarketRegime.TRENDING;
      }
    }
    
    // Risk-off detection
    const flowData = Array.from(this.flowAnalysis.values());
    const sellPressure = flowData.reduce((sum, f) => sum + (f.netFlow && f.netFlow < 0 ? 1 : 0), 0);
    if (sellPressure > flowData.length * 0.7) {
      newRegime = MarketRegime.RISK_OFF;
    }
    
    // Emit regime change
    if (newRegime !== this.currentRegime) {
      const previousRegime = this.currentRegime;
      this.currentRegime = newRegime;
      
      this.emit('regime-change', {
        previous: previousRegime,
        current: newRegime,
        timestamp: Date.now()
      });
      
      // Generate insight
      this.generateInsight({
        type: InsightType.REGIME_CHANGE,
        priority: InsightPriority.HIGH,
        confidence: 0.8,
        message: `Market regime changed from ${previousRegime} to ${newRegime}`,
        data: {
          previousRegime,
          newRegime,
          volumePercentile: (volumeMetric.current / volumeMetric.percentiles.p50) * 100,
          spreadPercentile: (spreadMetric.current / spreadMetric.percentiles.p50) * 100
        },
        timestamp: Date.now()
      });
    }
  }

  /**
   * Update volume profile
   */
  private updateVolumeProfile(symbol: string, volume: any): void {
    const profile: VolumeProfile = {
      symbol,
      venue: volume.venue || 'unknown',
      timestamp: Date.now(),
      buyVolume: volume.buyVolume || 0,
      sellVolume: volume.sellVolume || 0,
      totalVolume: volume.totalVolume || 0,
      vwap: volume.vwap || 0,
      priceRanges: volume.priceRanges || []
    };
    
    this.volumeProfiles.set(symbol, profile);
    
    // Update rolling volume metric
    this.updateRollingMetric('volume', profile.totalVolume);
  }

  /**
   * Update flow analysis
   */
  private updateFlowAnalysis(symbol: string, flows: any): void {
    const analysis: FlowAnalysis = {
      venue: 'aggregated',
      symbol,
      period: 60000,
      metrics: {
        buyVolume: flows.buyFlow || 0,
        sellVolume: flows.sellFlow || 0,
        netVolume: flows.netFlow || 0,
        buyPressure: 0.5,
        sellPressure: 0.5,
        largeOrderRatio: 0,
        oddLotRatio: 0,
        sweepRatio: 0
      },
      classification: 'neutral',
      toxicity: 0,
      timestamp: Date.now(),
      netFlow: new BigNumber(flows.netFlow || 0),
      buyFlow: new BigNumber(flows.buyFlow || 0),
      sellFlow: new BigNumber(flows.sellFlow || 0),
      largeOrderFlow: Boolean(flows.largeOrderFlow),
      smartMoneyFlow: new BigNumber(flows.smartMoneyFlow || 0),
      sentiment: flows.netFlow > 0 ? 'bullish' : flows.netFlow < 0 ? 'bearish' : 'neutral'
    };
    
    this.flowAnalysis.set(symbol, analysis);
  }

  /**
   * Update correlation matrices
   */
  private updateCorrelations(prices: any[]): void {
    // Simplified correlation calculation
    const symbols = prices.map(p => p.symbol);
    const returns: Map<string, number[]> = new Map();
    
    // Calculate returns
    for (const price of prices) {
      if (!returns.has(price.symbol)) {
        returns.set(price.symbol, []);
      }
      returns.get(price.symbol)!.push(price.return || 0);
    }
    
    // Calculate correlation matrix
    const matrix: CorrelationMatrix = {
      symbols,
      matrix: [],
      timestamp: Date.now(),
      period: '5m' // 5 minute correlations
    };
    
    for (let i = 0; i < symbols.length; i++) {
      matrix.matrix[i] = [];
      for (let j = 0; j < symbols.length; j++) {
        if (i === j) {
          matrix.matrix[i][j] = 1;
        } else {
          const corr = this.calculateCorrelation(
            returns.get(symbols[i]) || [],
            returns.get(symbols[j]) || []
          );
          matrix.matrix[i][j] = corr;
        }
      }
    }
    
    this.correlationMatrices.set('5m', matrix);
  }

  /**
   * Update model metrics
   */
  private updateModelMetrics(evaluation: ModelEvaluation): void {
    const n = evaluation.predictions.length;
    if (n === 0) return;
    
    // Mean Squared Error
    let mse = 0;
    let mae = 0;
    let hits = 0;
    
    for (let i = 0; i < n; i++) {
      const error = evaluation.predictions[i] - evaluation.actuals[i];
      mse += error * error;
      mae += Math.abs(error);
      
      // Hit rate (direction)
      if (i > 0) {
        const predDirection = evaluation.predictions[i] > evaluation.predictions[i-1];
        const actualDirection = evaluation.actuals[i] > evaluation.actuals[i-1];
        if (predDirection === actualDirection) hits++;
      }
    }
    
    evaluation.metrics.mse = mse / n;
    evaluation.metrics.mae = mae / n;
    evaluation.metrics.hitRate = hits / Math.max(1, n - 1);
    
    // Sharpe ratio of predictions
    const returns = [];
    for (let i = 1; i < n; i++) {
      returns.push((evaluation.actuals[i] - evaluation.actuals[i-1]) / evaluation.actuals[i-1]);
    }
    
    if (returns.length > 0) {
      const meanReturn = returns.reduce((a, b) => a + b, 0) / returns.length;
      const stdReturn = Math.sqrt(
        returns.reduce((sum, r) => sum + Math.pow(r - meanReturn, 2), 0) / returns.length
      );
      
      evaluation.metrics.sharpe = stdReturn > 0 ? (meanReturn * 252) / (stdReturn * Math.sqrt(252)) : 0;
    }
    
    // Max drawdown
    let peak = evaluation.actuals[0];
    let maxDrawdown = 0;
    
    for (const value of evaluation.actuals) {
      if (value > peak) peak = value;
      const drawdown = (peak - value) / peak;
      if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    }
    
    evaluation.metrics.maxDrawdown = maxDrawdown;
  }

  /**
   * Check for insights based on trade
   */
  private checkForInsights(trade: any): void {
    // High slippage alert
    const slippageMetric = this.rollingMetrics.get('slippage');
    if (slippageMetric && trade.slippage > slippageMetric.percentiles.p95) {
      this.generateInsight({
        type: InsightType.PERFORMANCE_ALERT,
        priority: InsightPriority.HIGH,
        confidence: 0.9,
        message: `High slippage detected: ${(trade.slippage * 10000).toFixed(1)} bps`,
        data: {
          slippage: trade.slippage,
          p95Slippage: slippageMetric.percentiles.p95,
          symbol: trade.symbol,
          venue: trade.venue
        },
        timestamp: Date.now()
      });
    }
    
    // Unusual volume
    const volumeMetric = this.rollingMetrics.get('volume');
    if (volumeMetric && trade.volume > volumeMetric.percentiles.p99) {
      this.generateInsight({
        type: InsightType.UNUSUAL_ACTIVITY,
        priority: InsightPriority.MEDIUM,
        confidence: 0.85,
        message: `Unusual volume spike detected`,
        data: {
          volume: trade.volume,
          p99Volume: volumeMetric.percentiles.p99,
          symbol: trade.symbol
        },
        timestamp: Date.now()
      });
    }
  }

  /**
   * Generate and emit insight
   */
  private generateInsight(insight: MarketInsight): void {
    this.insightsGenerated++;
    this.emit('insight', insight);
  }

  /**
   * Get recent insights
   */
  private getRecentInsights(): MarketInsight[] {
    // This would be stored in production
    return [];
  }

  /**
   * Calculate trend
   */
  private calculateTrend(values: number[]): number {
    if (values.length < 2) return 0;
    
    // Simple linear regression
    const n = values.length;
    const x = Array.from({ length: n }, (_, i) => i);
    const y = values;
    
    const sumX = x.reduce((a, b) => a + b, 0);
    const sumY = y.reduce((a, b) => a + b, 0);
    const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
    const sumX2 = x.reduce((sum, xi) => sum + xi * xi, 0);
    
    const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
    
    return slope;
  }

  /**
   * Calculate correlation
   */
  private calculateCorrelation(x: number[], y: number[]): number {
    if (x.length !== y.length || x.length === 0) return 0;
    
    const n = x.length;
    const meanX = x.reduce((a, b) => a + b, 0) / n;
    const meanY = y.reduce((a, b) => a + b, 0) / n;
    
    let numerator = 0;
    let denomX = 0;
    let denomY = 0;
    
    for (let i = 0; i < n; i++) {
      const dx = x[i] - meanX;
      const dy = y[i] - meanY;
      numerator += dx * dy;
      denomX += dx * dx;
      denomY += dy * dy;
    }
    
    const denominator = Math.sqrt(denomX * denomY);
    
    return denominator > 0 ? numerator / denominator : 0;
  }

  /**
   * Update max drawdown
   */
  private updateMaxDrawdown(): void {
    const pnlMetric = this.rollingMetrics.get('pnl');
    if (!pnlMetric || pnlMetric.values.length === 0) return;
    
    let peak = 0;
    let maxDrawdown = 0;
    let cumPnL = 0;
    
    for (const pnl of pnlMetric.values) {
      cumPnL += pnl;
      if (cumPnL > peak) peak = cumPnL;
      const drawdown = peak > 0 ? (peak - cumPnL) / peak : 0;
      if (drawdown > maxDrawdown) maxDrawdown = drawdown;
    }
    
    this.performanceMetrics.maxDrawdown = maxDrawdown;
  }

  /**
   * Convert regime to number for Prometheus
   */
  private regimeToNumber(regime: MarketRegime): number {
    const regimeMap: Record<MarketRegime, number> = {
      [MarketRegime.NORMAL]: 0,
      [MarketRegime.HIGH_VOLATILITY]: 1,
      [MarketRegime.LOW_LIQUIDITY]: 2,
      [MarketRegime.TRENDING]: 3,
      [MarketRegime.RISK_OFF]: 4,
      [MarketRegime.BULLISH_TREND]: 5,
      [MarketRegime.BEARISH_TREND]: 6,
      [MarketRegime.RANGEBOUND]: 7,
      [MarketRegime.MEAN_REVERTING]: 8,
      [MarketRegime.LOW_VOLATILITY]: 9,
      [MarketRegime.HIGH_LIQUIDITY]: 10,
      [MarketRegime.MARKET_STRESS]: 11,
      [MarketRegime.BULL_VOLATILE]: 12,
      [MarketRegime.BEAR_VOLATILE]: 13,
      [MarketRegime.RANGEBOUND_LOW_VOL]: 14,
      [MarketRegime.UNKNOWN]: 15
    };
    
    return regimeMap[regime] || 0;
  }

  /**
   * Export Prometheus metrics
   */
  private exportPrometheusMetrics(): void {
    // In production, this would push to Prometheus gateway
    // or expose an HTTP endpoint
    const metrics = this.getPrometheusMetrics();
    this.emit('metrics-export', metrics);
  }
} 