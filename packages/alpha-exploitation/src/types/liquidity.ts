/**
 * Liquidity Types - Advanced liquidity analytics and provision
 */

import { BigNumber } from 'bignumber.js';

export interface LiquidityOpportunity {
  id: string;
  venue: string;
  symbol: string;
  type: LiquidityType;
  spread: number; // basis points
  depth: BigNumber;
  imbalance: number; // -1 to 1
  expectedYield: number; // annualized basis points
  riskLevel: 'low' | 'medium' | 'high';
  capital: BigNumber;
  duration: number; // milliseconds
  metadata: {
    historicalFillRate?: number;
    competitorCount?: number;
    venueIncentives?: number;
  };
}

export enum LiquidityType {
  MARKET_MAKING = 'MARKET_MAKING',
  PASSIVE_PROVISION = 'PASSIVE_PROVISION',
  REBATE_CAPTURE = 'REBATE_CAPTURE',
  SPREAD_CAPTURE = 'SPREAD_CAPTURE',
  INVENTORY_MANAGEMENT = 'INVENTORY_MANAGEMENT',
  CROSS_VENUE_MAKING = 'CROSS_VENUE_MAKING'
}

export interface LiquidityPool {
  protocol: string;
  poolId: string;
  token0: string;
  token1: string;
  tvl: BigNumber;
  volume24h: BigNumber;
  fee: number; // basis points
  utilization: number; // 0-1
  impermanentLoss: number; // percentage
}

export interface LiquidityMetadata {
  venue: string;
  lastUpdate: number;
  aggregatedDepth: {
    bids: BigNumber;
    asks: BigNumber;
    total: BigNumber;
  };
  topOfBook: {
    bid: number;
    ask: number;
    spread: number;
  };
  marketQuality: {
    spreadStability: number; // 0-1
    depthResilience: number; // 0-1
    priceEfficiency: number; // 0-1
  };
}

export interface SmartLiquidityRoute {
  venues: VenueLiquidity[];
  aggregatedLiquidity: BigNumber;
  weightedSpread: number;
  executionPath: ExecutionStep[];
  estimatedImpact: number; // basis points
  confidence: number; // 0-1
}

export interface VenueLiquidity {
  venue: string;
  available: BigNumber;
  spread: number;
  depth: {
    [price: string]: BigNumber;
  };
  restrictions?: {
    minSize?: BigNumber;
    maxSize?: BigNumber;
    timeWindow?: number;
  };
}

export interface ExecutionStep {
  venue: string;
  size: BigNumber;
  price: number;
  timing: number; // offset in milliseconds
  contingent: boolean;
} 