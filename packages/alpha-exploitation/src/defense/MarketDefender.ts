/**
 * MarketDefender - Elite market manipulation defense and protection
 * 
 * Features:
 * - Real-time manipulation detection (pump/dumps, wash trading, spoofing)
 * - Anomaly signal monitoring from AI Core
 * - Emergency halt triggers and position adjustments
 * - Risk engine integration for exposure reduction
 * - Defensive strategy execution
 */

import { EventEmitter } from 'events';
import { BigNumber } from 'bignumber.js';
import {
  AlphaExploitationConfig,
  AlphaOpportunity,
  ThreatDetection,
  ThreatType,
  ThreatSeverity,
  ThreatIndicator,
  DefensiveAction,
  DefenseActionType,
  MarketManipulation,
  ManipulationType,
  ManipulationEvidence,
  ProtectionStatus,
  ActiveProtection,
  ProtectionType
} from '@noderr/types';
import { DEFENSE_CONFIG } from '@noderr/config/default';

interface SuspiciousActivity {
  type: string;
  venue: string;
  symbol: string;
  timestamp: number;
  severity: number; // 0-1
  indicators: any[];
}

interface OrderPattern {
  venue: string;
  symbol: string;
  pattern: 'normal' | 'suspicious' | 'malicious';
  confidence: number;
  details: any;
}

interface MarketState {
  symbol: string;
  normalSpread: number;
  normalVolume: number;
  priceStdev: number;
  volumeStdev: number;
  lastUpdate: number;
}

export class MarketDefender extends EventEmitter {
  private config: AlphaExploitationConfig;
  private isRunning: boolean = false;
  
  // Tracking data
  private suspiciousActivities: Map<string, SuspiciousActivity[]> = new Map();
  private orderPatterns: Map<string, OrderPattern[]> = new Map();
  private marketStates: Map<string, MarketState> = new Map();
  private blacklistedAddresses: Set<string> = new Set();
  
  // Protection state
  private protectionStatus: ProtectionStatus;
  private activeThreats: Map<string, ThreatDetection> = new Map();
  private defensiveActions: Map<string, DefensiveAction[]> = new Map();
  
  // Performance metrics
  private threatsDetected: number = 0;
  private attacksPrevented: number = 0;
  private falsePositives: number = 0;
  
  // Monitoring intervals
  private monitoringInterval?: NodeJS.Timeout;
  private cleanupInterval?: NodeJS.Timeout;

  constructor(config: AlphaExploitationConfig) {
    super();
    this.config = config;
    
    // Initialize protection status
    this.protectionStatus = {
      active: true,
      level: 'standard',
      activeMeasures: this.initializeProtections(),
      recentThreats: [],
      performance: {
        threatsDetected: 0,
        attacksPrevented: 0,
        falsePositives: 0,
        avgResponseTime: 0
      }
    };
  }

  /**
   * Start the market defender
   */
  async start(): Promise<void> {
    if (this.isRunning) return;
    
    this.isRunning = true;
    
    // Initialize blacklist with known bad actors
    this.initializeBlacklist();
    
    // Start monitoring
    this.monitoringInterval = setInterval(
      () => this.performSecurityScan(),
      1000 // 1 second scan interval
    );
    
    // Periodic cleanup
    this.cleanupInterval = setInterval(
      () => this.cleanupOldData(),
      300000 // 5 minutes
    );
    
    this.emit('started');
  }

  /**
   * Stop the market defender
   */
  async stop(): Promise<void> {
    if (!this.isRunning) return;
    
    this.isRunning = false;
    
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }
    
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    
    this.emit('stopped');
  }

  /**
   * Check if an opportunity is safe to execute
   */
  async checkOpportunity(opportunity: AlphaOpportunity): Promise<boolean> {
    const startTime = Date.now();
    
    // Check blacklist
    if (this.isBlacklisted(opportunity)) {
      this.emit('threat', {
        id: `threat_${Date.now()}`,
        type: ThreatType.MANIPULATION,
        severity: ThreatSeverity.HIGH,
        source: opportunity.metadata?.venue || 'unknown',
        target: opportunity.metadata?.symbol || 'unknown',
        confidence: 0.9,
        timestamp: Date.now(),
        indicators: [{
          type: 'blacklisted_entity',
          value: opportunity.metadata?.address || opportunity.metadata?.venue,
          confidence: 1,
          timestamp: Date.now()
        }],
        suggestedAction: {
          type: DefenseActionType.CANCEL_ORDERS,
          parameters: { opportunityId: opportunity.id },
          urgency: 'immediate',
          expectedOutcome: 'Avoid interaction with blacklisted entity'
        }
      });
      return false;
    }
    
    // Check for manipulation patterns
    const manipulationRisk = this.assessManipulationRisk(opportunity);
    if (manipulationRisk > 0.7) {
      this.emit('threat', {
        id: `threat_${Date.now()}`,
        type: ThreatType.MANIPULATION,
        severity: manipulationRisk > 0.9 ? ThreatSeverity.CRITICAL : ThreatSeverity.HIGH,
        source: opportunity.metadata?.venue || 'unknown',
        target: opportunity.metadata?.symbol || 'unknown',
        confidence: manipulationRisk,
        timestamp: Date.now(),
        indicators: this.getManipulationIndicators(opportunity),
        suggestedAction: {
          type: DefenseActionType.REDUCE_EXPOSURE,
          parameters: { 
            symbol: opportunity.metadata?.symbol,
            reductionPercent: 50
          },
          urgency: 'high',
          expectedOutcome: 'Reduce exposure to potential manipulation'
        }
      });
      return false;
    }
    
    // Check anomaly score
    const anomalyScore = this.calculateAnomalyScore(opportunity);
    if (anomalyScore > 0.8) {
      this.emit('threat', {
        id: `threat_${Date.now()}`,
        type: ThreatType.API_ABUSE,
        severity: ThreatSeverity.MEDIUM,
        source: opportunity.metadata?.venue || 'unknown',
        target: opportunity.metadata?.symbol || 'unknown',
        confidence: anomalyScore,
        timestamp: Date.now(),
        indicators: [{
          type: 'anomaly_score',
          value: anomalyScore,
          confidence: 0.8,
          timestamp: Date.now()
        }],
        suggestedAction: {
          type: DefenseActionType.DELAY_EXECUTION,
          parameters: { 
            delay: 5000,
            opportunityId: opportunity.id
          },
          urgency: 'normal',
          expectedOutcome: 'Delay execution to gather more data'
        }
      });
      
      // High anomaly but not blocking
      this.protectionStatus.level = 'enhanced';
    }
    
    const responseTime = Date.now() - startTime;
    this.updateResponseTime(responseTime);
    
    return true;
  }

  /**
   * Update market state from external sources
   */
  updateMarketState(marketState: any): void {
    // Process anomaly signals from AI Core
    if (marketState.anomalySignals) {
      this.processAnomalySignals(marketState.anomalySignals);
    }
    
    // Update market baselines
    if (marketState.symbol && marketState.stats) {
      this.updateMarketBaseline(marketState.symbol, marketState.stats);
    }
    
    // Process order patterns
    if (marketState.orderPatterns) {
      this.analyzeOrderPatterns(marketState.orderPatterns);
    }
  }

  /**
   * Main security scanning loop
   */
  private async performSecurityScan(): Promise<void> {
    // Scan for different types of threats
    this.detectWashTrading();
    this.detectSpoofing();
    this.detectPumpAndDump();
    this.detectLayering();
    this.detectMomentumIgnition();
    
    // Update protection status
    this.updateProtectionStatus();
    
    // Execute defensive actions if needed
    this.executeDefensiveActions();
  }

  /**
   * Detect wash trading patterns
   */
  private detectWashTrading(): void {
    for (const [symbol, activities] of this.suspiciousActivities) {
      const recentActivities = activities.filter(
        a => Date.now() - a.timestamp < DEFENSE_CONFIG.manipulation.washTradeWindow
      );
      
      // Look for circular trading patterns
      const addresses = new Map<string, number>();
      for (const activity of recentActivities) {
        const addr = activity.indicators.find(i => i.type === 'address')?.value;
        if (addr) {
          addresses.set(addr, (addresses.get(addr) || 0) + 1);
        }
      }
      
      // Check for repeated trades from same addresses
      for (const [addr, count] of addresses) {
        if (count > 5) { // Suspicious frequency
          const threat: ThreatDetection = {
            id: `wash_${symbol}_${Date.now()}`,
            type: ThreatType.WASH_TRADING,
            severity: ThreatSeverity.HIGH,
            source: addr,
            target: symbol,
            confidence: Math.min(0.9, count / 10),
            timestamp: Date.now(),
            indicators: [{
              type: 'trade_frequency',
              value: count,
              confidence: 0.8,
              timestamp: Date.now()
            }],
            suggestedAction: {
              type: DefenseActionType.ALERT_ONLY,
              parameters: { symbol, address: addr },
              urgency: 'normal',
              expectedOutcome: 'Monitor for continued wash trading'
            },
            metadata: {
              tradeCount: count,
              timeWindow: DEFENSE_CONFIG.manipulation.washTradeWindow
            }
          };
          
          this.activeThreats.set(threat.id, threat);
          this.emit('threat', threat);
          this.threatsDetected++;
        }
      }
    }
  }

  /**
   * Detect spoofing (fake orders)
   */
  private detectSpoofing(): void {
    for (const [symbol, patterns] of this.orderPatterns) {
      const recentPatterns = patterns.filter(
        p => Date.now() - p.details.timestamp < 30000 // 30 seconds
      );
      
      // Look for large orders that get cancelled quickly
      const cancelledLargeOrders = recentPatterns.filter(
        p => p.details.cancelled && p.details.size > 100000 // $100k+
      );
      
      if (cancelledLargeOrders.length > 3) {
        const threat: ThreatDetection = {
          id: `spoof_${symbol}_${Date.now()}`,
          type: ThreatType.SPOOFING,
          severity: ThreatSeverity.HIGH,
          source: cancelledLargeOrders[0].venue,
          target: symbol,
          confidence: Math.min(0.9, cancelledLargeOrders.length / 5),
          timestamp: Date.now(),
          indicators: cancelledLargeOrders.map(order => ({
            type: 'cancelled_large_order',
            value: order.details,
            confidence: 0.7,
            timestamp: order.details.timestamp
          })),
          suggestedAction: {
            type: DefenseActionType.ADJUST_SPREADS,
            parameters: { 
              symbol,
              spreadMultiplier: 1.5
            },
            urgency: 'high',
            expectedOutcome: 'Widen spreads to avoid spoofed levels'
          },
          metadata: {
            cancelledOrderCount: cancelledLargeOrders.length,
            totalValue: cancelledLargeOrders.reduce((sum, o) => sum + o.details.size, 0)
          }
        };
        
        this.activeThreats.set(threat.id, threat);
        this.emit('threat', threat);
        this.threatsDetected++;
      }
    }
  }

  /**
   * Detect pump and dump schemes
   */
  private detectPumpAndDump(): void {
    for (const [symbol, state] of this.marketStates) {
      const activities = this.suspiciousActivities.get(symbol) || [];
      const recentActivities = activities.filter(
        a => Date.now() - a.timestamp < 300000 // 5 minutes
      );
      
      // Check for abnormal price movement with volume
      const priceSpike = recentActivities.find(
        a => a.type === 'price_spike' && a.severity > 0.7
      );
      
      const volumeSpike = recentActivities.find(
        a => a.type === 'volume_spike' && a.severity > 0.7
      );
      
      if (priceSpike && volumeSpike) {
        const threat: ThreatDetection = {
          id: `pump_${symbol}_${Date.now()}`,
          type: ThreatType.PUMP_DUMP,
          severity: ThreatSeverity.CRITICAL,
          source: 'multiple_venues',
          target: symbol,
          confidence: 0.8,
          timestamp: Date.now(),
          indicators: [
            {
              type: 'price_spike',
              value: priceSpike.severity,
              confidence: 0.8,
              timestamp: priceSpike.timestamp
            },
            {
              type: 'volume_spike',
              value: volumeSpike.severity,
              confidence: 0.8,
              timestamp: volumeSpike.timestamp
            }
          ],
          suggestedAction: {
            type: DefenseActionType.EMERGENCY_STOP,
            parameters: { symbol },
            urgency: 'immediate',
            expectedOutcome: 'Halt trading to avoid pump and dump losses'
          },
          metadata: {
            priceChange: priceSpike.indicators[0]?.value,
            volumeChange: volumeSpike.indicators[0]?.value
          }
        };
        
        this.activeThreats.set(threat.id, threat);
        this.emit('threat', threat);
        this.threatsDetected++;
      }
    }
  }

  /**
   * Detect layering (multiple orders at different levels)
   */
  private detectLayering(): void {
    for (const [symbol, patterns] of this.orderPatterns) {
      // Look for multiple orders placed at incremental price levels
      const layeredOrders = patterns.filter(
        p => p.pattern === 'suspicious' && 
             p.details.type === 'layered' &&
             Date.now() - p.details.timestamp < 60000
      );
      
      if (layeredOrders.length >= DEFENSE_CONFIG.manipulation.layeringDepth) {
        const threat: ThreatDetection = {
          id: `layer_${symbol}_${Date.now()}`,
          type: ThreatType.LAYERING,
          severity: ThreatSeverity.MEDIUM,
          source: layeredOrders[0].venue,
          target: symbol,
          confidence: 0.7,
          timestamp: Date.now(),
          indicators: layeredOrders.map(order => ({
            type: 'layered_order',
            value: order.details,
            confidence: 0.6,
            timestamp: order.details.timestamp
          })),
          suggestedAction: {
            type: DefenseActionType.SWITCH_VENUE,
            parameters: { 
              currentVenue: layeredOrders[0].venue,
              symbol
            },
            urgency: 'normal',
            expectedOutcome: 'Avoid manipulated order book'
          },
          metadata: {
            layerCount: layeredOrders.length,
            priceRange: this.calculatePriceRange(layeredOrders)
          }
        };
        
        this.activeThreats.set(threat.id, threat);
        this.emit('threat', threat);
        this.threatsDetected++;
      }
    }
  }

  /**
   * Detect momentum ignition attempts
   */
  private detectMomentumIgnition(): void {
    for (const [symbol, activities] of this.suspiciousActivities) {
      // Look for aggressive taking followed by passive orders
      const aggressiveOrders = activities.filter(
        a => a.type === 'aggressive_sweep' && 
             Date.now() - a.timestamp < 10000 // 10 seconds
      );
      
      if (aggressiveOrders.length > 0) {
        const patterns = this.orderPatterns.get(symbol) || [];
        const passiveOrders = patterns.filter(
          p => p.details.side === aggressiveOrders[0].indicators[0]?.side &&
               p.details.timestamp > aggressiveOrders[0].timestamp
        );
        
        if (passiveOrders.length > 2) {
          const threat: ThreatDetection = {
            id: `momentum_${symbol}_${Date.now()}`,
            type: ThreatType.MANIPULATION,
            severity: ThreatSeverity.HIGH,
            source: aggressiveOrders[0].venue,
            target: symbol,
            confidence: 0.75,
            timestamp: Date.now(),
            indicators: [{
              type: 'momentum_ignition',
              value: {
                aggressiveCount: aggressiveOrders.length,
                passiveCount: passiveOrders.length
              },
              confidence: 0.7,
              timestamp: Date.now()
            }],
            suggestedAction: {
              type: DefenseActionType.ENABLE_PROTECTION,
              parameters: { 
                protectionType: ProtectionType.EXECUTION_DELAY,
                duration: 30000 // 30 seconds
              },
              urgency: 'high',
              expectedOutcome: 'Avoid being swept in momentum ignition'
            },
            metadata: {
              pattern: 'aggressive_then_passive',
              direction: aggressiveOrders[0].indicators[0]?.side
            }
          };
          
          this.activeThreats.set(threat.id, threat);
          this.emit('threat', threat);
          this.threatsDetected++;
        }
      }
    }
  }

  /**
   * Process anomaly signals from AI Core
   */
  private processAnomalySignals(signals: any[]): void {
    for (const signal of signals) {
      if (signal.type === 'manipulation' && signal.confidence > 0.7) {
        const activity: SuspiciousActivity = {
          type: 'ai_anomaly',
          venue: signal.venue || 'unknown',
          symbol: signal.symbol,
          timestamp: Date.now(),
          severity: signal.confidence,
          indicators: [signal]
        };
        
        if (!this.suspiciousActivities.has(signal.symbol)) {
          this.suspiciousActivities.set(signal.symbol, []);
        }
        
        this.suspiciousActivities.get(signal.symbol)!.push(activity);
        
        // Trigger immediate analysis
        this.analyzeAnomalyPattern(signal.symbol, activity);
      }
    }
  }

  /**
   * Analyze anomaly patterns
   */
  private analyzeAnomalyPattern(symbol: string, activity: SuspiciousActivity): void {
    const recentActivities = this.suspiciousActivities.get(symbol) || [];
    const anomalyCount = recentActivities.filter(
      a => a.type === 'ai_anomaly' && Date.now() - a.timestamp < 60000
    ).length;
    
    if (anomalyCount > 3) {
      // Multiple anomalies detected by AI
      const threat: ThreatDetection = {
        id: `anomaly_${symbol}_${Date.now()}`,
        type: ThreatType.MANIPULATION,
        severity: ThreatSeverity.HIGH,
        source: 'ai_detection',
        target: symbol,
        confidence: 0.85,
        timestamp: Date.now(),
        indicators: [{
          type: 'ai_anomaly_cluster',
          value: anomalyCount,
          confidence: 0.85,
          timestamp: Date.now()
        }],
        suggestedAction: {
          type: DefenseActionType.REDUCE_EXPOSURE,
          parameters: { 
            symbol,
            reductionPercent: 75
          },
          urgency: 'immediate',
          expectedOutcome: 'Reduce exposure based on AI anomaly detection'
        },
        metadata: {
          anomalyCount,
          aiConfidence: activity.severity
        }
      };
      
      this.activeThreats.set(threat.id, threat);
      this.emit('threat', threat);
      this.threatsDetected++;
    }
  }

  /**
   * Analyze order patterns
   */
  private analyzeOrderPatterns(patterns: any[]): void {
    for (const pattern of patterns) {
      const orderPattern: OrderPattern = {
        venue: pattern.venue,
        symbol: pattern.symbol,
        pattern: this.classifyPattern(pattern),
        confidence: pattern.confidence || 0.5,
        details: pattern
      };
      
      if (!this.orderPatterns.has(pattern.symbol)) {
        this.orderPatterns.set(pattern.symbol, []);
      }
      
      this.orderPatterns.get(pattern.symbol)!.push(orderPattern);
      
      // Detect suspicious patterns
      if (orderPattern.pattern === 'suspicious' || orderPattern.pattern === 'malicious') {
        const activity: SuspiciousActivity = {
          type: 'order_pattern',
          venue: pattern.venue,
          symbol: pattern.symbol,
          timestamp: Date.now(),
          severity: orderPattern.pattern === 'malicious' ? 0.9 : 0.6,
          indicators: [pattern]
        };
        
        if (!this.suspiciousActivities.has(pattern.symbol)) {
          this.suspiciousActivities.set(pattern.symbol, []);
        }
        
        this.suspiciousActivities.get(pattern.symbol)!.push(activity);
      }
    }
  }

  /**
   * Update market baseline statistics
   */
  private updateMarketBaseline(symbol: string, stats: any): void {
    const existing = this.marketStates.get(symbol);
    
    if (!existing || Date.now() - existing.lastUpdate > 300000) { // 5 minutes
      this.marketStates.set(symbol, {
        symbol,
        normalSpread: stats.avgSpread || 10,
        normalVolume: stats.avgVolume || 1000000,
        priceStdev: stats.priceStdev || 0.01,
        volumeStdev: stats.volumeStdev || 0.2,
        lastUpdate: Date.now()
      });
    } else {
      // Update with exponential moving average
      const alpha = 0.1;
      existing.normalSpread = alpha * stats.avgSpread + (1 - alpha) * existing.normalSpread;
      existing.normalVolume = alpha * stats.avgVolume + (1 - alpha) * existing.normalVolume;
      existing.priceStdev = alpha * stats.priceStdev + (1 - alpha) * existing.priceStdev;
      existing.volumeStdev = alpha * stats.volumeStdev + (1 - alpha) * existing.volumeStdev;
      existing.lastUpdate = Date.now();
    }
  }

  /**
   * Execute defensive actions
   */
  private executeDefensiveActions(): void {
    for (const [threatId, actions] of this.defensiveActions) {
      for (const action of actions) {
        switch (action.type) {
          case DefenseActionType.EMERGENCY_STOP:
            this.emit('emergency-stop', action.parameters);
            break;
            
          case DefenseActionType.REDUCE_EXPOSURE:
            this.emit('reduce-exposure', action.parameters);
            break;
            
          case DefenseActionType.SWITCH_VENUE:
            this.emit('switch-venue', action.parameters);
            break;
            
          case DefenseActionType.ENABLE_PROTECTION:
            this.enableProtection(action.parameters.protectionType);
            break;
            
          default:
            // Other actions are informational or handled elsewhere
            break;
        }
      }
    }
    
    // Clear executed actions
    this.defensiveActions.clear();
  }

  /**
   * Enable specific protection mechanism
   */
  private enableProtection(type: ProtectionType): void {
    const protection = this.protectionStatus.activeMeasures.find(
      (m: ActiveProtection) => m.type === type
    );
    
    if (protection && !protection.enabled) {
      protection.enabled = true;
      this.emit('protection-enabled', { type });
    }
  }

  /**
   * Check if opportunity involves blacklisted entities
   */
  private isBlacklisted(opportunity: AlphaOpportunity): boolean {
    const venue = opportunity.metadata?.venue;
    const address = opportunity.metadata?.address;
    const counterparty = opportunity.metadata?.counterparty;
    
    return !!(venue && this.blacklistedAddresses.has(venue)) ||
           !!(address && this.blacklistedAddresses.has(address)) ||
           !!(counterparty && this.blacklistedAddresses.has(counterparty));
  }

  /**
   * Assess manipulation risk for opportunity
   */
  private assessManipulationRisk(opportunity: AlphaOpportunity): number {
    let risk = 0;
    const symbol = opportunity.metadata?.symbol;
    
    if (!symbol) return 0;
    
    // Check recent threats
    const recentThreats = Array.from(this.activeThreats.values()).filter(
      t => t.target === symbol && Date.now() - t.timestamp < 300000
    );
    
    if (recentThreats.length > 0) {
      risk += 0.3 * recentThreats.length;
    }
    
    // Check suspicious activities
    const activities = this.suspiciousActivities.get(symbol) || [];
    const recentSuspicious = activities.filter(
      a => Date.now() - a.timestamp < 60000
    );
    
    if (recentSuspicious.length > 2) {
      risk += 0.2 * Math.min(recentSuspicious.length / 5, 1);
    }
    
    // Check if price/volume are abnormal
    const state = this.marketStates.get(symbol);
    if (state && opportunity.metadata?.price && opportunity.metadata?.volume) {
      const priceDeviation = Math.abs(opportunity.metadata.price - state.normalSpread) / state.priceStdev;
      const volumeDeviation = Math.abs(opportunity.metadata.volume - state.normalVolume) / state.volumeStdev;
      
      if (priceDeviation > 3) risk += 0.2;
      if (volumeDeviation > 3) risk += 0.2;
    }
    
    return Math.min(risk, 1);
  }

  /**
   * Calculate anomaly score for opportunity
   */
  private calculateAnomalyScore(opportunity: AlphaOpportunity): number {
    let score = 0;
    
    // Check if return is too good to be true
    if (opportunity.expectedReturn > 200) { // 200bps
      score += 0.3;
    }
    
    // Check if time horizon is suspiciously short
    if (opportunity.timeHorizon && opportunity.timeHorizon < 100) { // 100ms
      score += 0.2;
    }
    
    // Check if capital requirement is unusual
    if (opportunity.capital.gt(500000)) { // $500k
      score += 0.1;
    }
    
    // Check confidence vs return relationship
    if (opportunity.confidence > 0.9 && opportunity.expectedReturn > 100) {
      score += 0.2; // Too confident for high return
    }
    
    // Check risk score
    if (opportunity.riskScore && opportunity.riskScore < 0.1 && opportunity.expectedReturn > 50) {
      score += 0.2; // Risk seems underestimated
    }
    
    return Math.min(score, 1);
  }

  /**
   * Get manipulation indicators for opportunity
   */
  private getManipulationIndicators(opportunity: AlphaOpportunity): ThreatIndicator[] {
    const indicators: ThreatIndicator[] = [];
    const symbol = opportunity.metadata?.symbol;
    
    if (!symbol) return indicators;
    
    // Add relevant suspicious activities as indicators
    const activities = this.suspiciousActivities.get(symbol) || [];
    for (const activity of activities.slice(-5)) { // Last 5
      indicators.push({
        type: activity.type,
        value: activity.severity,
        confidence: 0.7,
        timestamp: activity.timestamp
      });
    }
    
    return indicators;
  }

  /**
   * Update protection status
   */
  private updateProtectionStatus(): void {
    const threatCount = this.activeThreats.size;
    
    // Adjust protection level based on threat count
    if (threatCount === 0) {
      this.protectionStatus.level = 'minimal';
    } else if (threatCount < 3) {
      this.protectionStatus.level = 'standard';
    } else if (threatCount < 5) {
      this.protectionStatus.level = 'enhanced';
    } else {
      this.protectionStatus.level = 'maximum';
    }
    
    // Update recent threats
    this.protectionStatus.recentThreats = Array.from(this.activeThreats.values())
      .sort((a, b) => b.timestamp - a.timestamp)
      .slice(0, 10);
    
    // Update performance metrics
    this.protectionStatus.performance = {
      threatsDetected: this.threatsDetected,
      attacksPrevented: this.attacksPrevented,
      falsePositives: this.falsePositives,
      avgResponseTime: this.getAverageResponseTime()
    };
  }

  /**
   * Update response time metrics
   */
  private updateResponseTime(responseTime: number): void {
    // Simple moving average (would use proper stats in production)
    const currentAvg = this.protectionStatus.performance.avgResponseTime;
    const weight = 0.1;
    this.protectionStatus.performance.avgResponseTime = 
      currentAvg * (1 - weight) + responseTime * weight;
  }

  /**
   * Get average response time
   */
  private getAverageResponseTime(): number {
    return this.protectionStatus.performance.avgResponseTime || 0;
  }

  /**
   * Classify order pattern
   */
  private classifyPattern(pattern: any): 'normal' | 'suspicious' | 'malicious' {
    // Simple classification logic
    if (pattern.anomalyScore > 0.8) return 'malicious';
    if (pattern.anomalyScore > 0.5) return 'suspicious';
    return 'normal';
  }

  /**
   * Calculate price range for layered orders
   */
  private calculatePriceRange(orders: OrderPattern[]): number {
    const prices = orders.map(o => o.details.price || 0);
    return Math.max(...prices) - Math.min(...prices);
  }

  /**
   * Initialize blacklist
   */
  private initializeBlacklist(): void {
    // Add known bad actors (would load from database in production)
    // These are example addresses
    this.blacklistedAddresses.add('0xBadActor1');
    this.blacklistedAddresses.add('0xBadActor2');
    this.blacklistedAddresses.add('malicious_venue');
  }

  /**
   * Initialize default protections
   */
  private initializeProtections(): ActiveProtection[] {
    return [
      {
        type: ProtectionType.MEV_PROTECTION,
        enabled: true,
        effectiveness: 0.9,
        cost: 5, // 5 basis points
        parameters: { method: 'flashbots' }
      },
      {
        type: ProtectionType.ORDER_RANDOMIZATION,
        enabled: true,
        effectiveness: 0.7,
        cost: 2,
        parameters: { maxDelay: 100 }
      },
      {
        type: ProtectionType.SPLIT_ROUTING,
        enabled: false,
        effectiveness: 0.8,
        cost: 3,
        parameters: { minSplits: 3 }
      },
      {
        type: ProtectionType.EXECUTION_DELAY,
        enabled: false,
        effectiveness: 0.6,
        cost: 1,
        parameters: { minDelay: 50, maxDelay: 200 }
      }
    ];
  }

  /**
   * Clean up old data
   */
  private cleanupOldData(): void {
    const cutoff = Date.now() - 3600000; // 1 hour
    
    // Clean suspicious activities
    for (const [symbol, activities] of this.suspiciousActivities) {
      const filtered = activities.filter(a => a.timestamp > cutoff);
      if (filtered.length === 0) {
        this.suspiciousActivities.delete(symbol);
      } else {
        this.suspiciousActivities.set(symbol, filtered);
      }
    }
    
    // Clean order patterns
    for (const [symbol, patterns] of this.orderPatterns) {
      const filtered = patterns.filter(p => p.details.timestamp > cutoff);
      if (filtered.length === 0) {
        this.orderPatterns.delete(symbol);
      } else {
        this.orderPatterns.set(symbol, filtered);
      }
    }
    
    // Clean old threats
    for (const [id, threat] of this.activeThreats) {
      if (threat.timestamp < cutoff) {
        this.activeThreats.delete(id);
      }
    }
  }

  /**
   * Get protection status
   */
  getProtectionStatus(): ProtectionStatus {
    return this.protectionStatus;
  }

  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    return {
      threatsDetected: this.threatsDetected,
      attacksPrevented: this.attacksPrevented,
      falsePositives: this.falsePositives,
      avgResponseTime: this.getAverageResponseTime(),
      activeThreats: this.activeThreats.size,
      protectionLevel: this.protectionStatus.level
    };
  }
}
 