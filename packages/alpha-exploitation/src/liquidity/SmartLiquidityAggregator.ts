/**
 * SmartLiquidityAggregator - Elite liquidity aggregation across venues
 * 
 * Features:
 * - Real-time order book aggregation
 * - Smart routing optimization
 * - Hidden liquidity detection
 * - Cross-venue arbitrage detection
 */

import { EventEmitter } from 'events';
import { BigNumber } from 'bignumber.js';
import {
  AlphaOpportunity,
  AlphaType,
  AlphaSource,
  AlphaPriority,
  AlphaExploitationConfig,
  ExecutionStep,
  MarketMicrostructure
} from '@noderr/types';
import { LIQUIDITY_CONFIG } from '../config/default';

interface OrderBook {
  venue: string;
  symbol: string;
  bids: Array<[number, number]>; // [price, size]
  asks: Array<[number, number]>;
  timestamp: number;
}

interface AggregatedLiquidity {
  symbol: string;
  venues: Map<string, OrderBook>;
  bestBid: { price: number; size: number; venue: string };
  bestAsk: { price: number; size: number; venue: string };
  totalBidLiquidity: BigNumber;
  totalAskLiquidity: BigNumber;
  spread: number;
  midPrice: number;
}

export class SmartLiquidityAggregator extends EventEmitter {
  private config: AlphaExploitationConfig;
  private orderBooks: Map<string, Map<string, OrderBook>> = new Map(); // symbol -> venue -> orderbook
  private aggregatedLiquidity: Map<string, AggregatedLiquidity> = new Map();
    private isRunning: boolean = false;  private updateInterval?: NodeJS.Timeout;
  
  // Performance tracking
  private aggregationLatency: number[] = [];
  private opportunitiesFound: number = 0;

  constructor(config: AlphaExploitationConfig) {
    super();
    this.config = config;
  }

  async start(): Promise<void> {
    if (this.isRunning) return;
    
    this.isRunning = true;
    
    // Initialize order book subscriptions for all venues
    await this.initializeVenueConnections();
    
    // Start aggregation loop
    this.updateInterval = setInterval(
      () => this.aggregateLiquidity(),
      LIQUIDITY_CONFIG.aggregation.updateFrequency
    );
    
    this.emit('started');
  }

  async stop(): Promise<void> {
    if (!this.isRunning) return;
    
    this.isRunning = false;
    
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
    
    // Clean up venue connections
    await this.cleanupVenueConnections();
    
    this.emit('stopped');
  }

  /**
   * Update market state with new data
   */
  updateMarketState(marketState: any): void {
    // Process market state updates
    if (marketState.orderBooks) {
      this.processOrderBookUpdates(marketState.orderBooks);
    }
  }

  /**
   * Get aggregated liquidity for a symbol
   */
  getAggregatedLiquidity(symbol: string): AggregatedLiquidity | undefined {
    return this.aggregatedLiquidity.get(symbol);
  }

  /**
   * Find optimal liquidity route for an order
   */
  findOptimalRoute(
    symbol: string,
    side: 'buy' | 'sell',
    size: BigNumber
  ): SmartLiquidityRoute | null {
    const aggregated = this.aggregatedLiquidity.get(symbol);
    if (!aggregated) return null;
    
    const startTime = process.hrtime.bigint();
    
    // Collect available liquidity from all venues
    const venueLiquidity: VenueLiquidity[] = [];
    let remainingSize = size;
    
    for (const [venue, orderBook] of aggregated.venues) {
      const levels = side === 'buy' ? orderBook.asks : orderBook.bids;
      const venueDepth: { [price: string]: BigNumber } = {};
      let venueAvailable = new BigNumber(0);
      
      for (const [price, levelSize] of levels) {
        if (remainingSize.lte(0)) break;
        
        const available = BigNumber.min(remainingSize, levelSize);
        venueDepth[price.toString()] = available;
        venueAvailable = venueAvailable.plus(available);
        remainingSize = remainingSize.minus(available);
      }
      
      if (venueAvailable.gt(0)) {
        venueLiquidity.push({
          venue,
          available: venueAvailable,
          spread: this.calculateVenueSpread(orderBook),
          depth: venueDepth
        });
      }
    }
    
    // Calculate optimal execution path
    const executionPath = this.optimizeExecutionPath(venueLiquidity, side, size);
    
    // Calculate metrics
    const aggregatedSize = venueLiquidity.reduce(
      (sum, v) => sum.plus(v.available),
      new BigNumber(0)
    );
    
    const weightedSpread = this.calculateWeightedSpread(venueLiquidity);
    const estimatedImpact = this.estimateMarketImpact(size, aggregatedSize);
    
    const latency = Number(process.hrtime.bigint() - startTime) / 1e6;
    this.aggregationLatency.push(latency);
    
    return {
      venues: venueLiquidity,
      aggregatedLiquidity: aggregatedSize,
      weightedSpread,
      executionPath,
      estimatedImpact,
      confidence: aggregatedSize.gte(size) ? 0.9 : 0.5
    };
  }

  /**
   * Aggregate liquidity across all venues
   */
  private async aggregateLiquidity(): Promise<void> {
    const symbols = Array.from(this.orderBooks.keys());
    
    for (const symbol of symbols) {
      const venueBooks = this.orderBooks.get(symbol);
      if (!venueBooks || venueBooks.size === 0) continue;
      
      // Find best bid/ask across venues
      let bestBid = { price: 0, size: 0, venue: '' };
      let bestAsk = { price: Infinity, size: 0, venue: '' };
      let totalBidLiquidity = new BigNumber(0);
      let totalAskLiquidity = new BigNumber(0);
      
      for (const [venue, orderBook] of venueBooks) {
        // Check staleness
        if (Date.now() - orderBook.timestamp > LIQUIDITY_CONFIG.aggregation.staleThreshold) {
          continue;
        }
        
        // Update best bid
        if (orderBook.bids.length > 0) {
          const [topBidPrice, topBidSize] = orderBook.bids[0];
          if (topBidPrice > bestBid.price) {
            bestBid = { price: topBidPrice, size: topBidSize, venue };
          }
          
          // Sum liquidity
          const bidLiquidity = orderBook.bids.reduce(
            (sum, [price, size]) => sum.plus(price * size),
            new BigNumber(0)
          );
          totalBidLiquidity = totalBidLiquidity.plus(bidLiquidity);
        }
        
        // Update best ask
        if (orderBook.asks.length > 0) {
          const [topAskPrice, topAskSize] = orderBook.asks[0];
          if (topAskPrice < bestAsk.price) {
            bestAsk = { price: topAskPrice, size: topAskSize, venue };
          }
          
          // Sum liquidity
          const askLiquidity = orderBook.asks.reduce(
            (sum, [price, size]) => sum.plus(price * size),
            new BigNumber(0)
          );
          totalAskLiquidity = totalAskLiquidity.plus(askLiquidity);
        }
      }
      
      // Calculate spread and mid price
      const spread = bestAsk.price - bestBid.price;
      const midPrice = (bestAsk.price + bestBid.price) / 2;
      
      // Store aggregated data
      this.aggregatedLiquidity.set(symbol, {
        symbol,
        venues: venueBooks,
        bestBid,
        bestAsk,
        totalBidLiquidity,
        totalAskLiquidity,
        spread,
        midPrice
      });
      
      // Check for opportunities
      this.checkForOpportunities(symbol, venueBooks, spread);
    }
  }

  /**
   * Check for liquidity-based opportunities
   */
  private checkForOpportunities(
    symbol: string,
    venues: Map<string, OrderBook>,
    spread: number
  ): void {
    // Cross-venue arbitrage
    const arbOpportunity = this.detectCrossVenueArbitrage(symbol, venues);
    if (arbOpportunity) {
      this.emit('opportunity', arbOpportunity);
      this.opportunitiesFound++;
    }
    
    // Market making opportunity
    const mmOpportunity = this.detectMarketMakingOpportunity(symbol, spread);
    if (mmOpportunity) {
      this.emit('opportunity', mmOpportunity);
      this.opportunitiesFound++;
    }
    
    // Liquidity imbalance
    const imbalanceOpportunity = this.detectLiquidityImbalance(symbol);
    if (imbalanceOpportunity) {
      this.emit('opportunity', imbalanceOpportunity);
      this.opportunitiesFound++;
    }
  }

  /**
   * Detect cross-venue arbitrage opportunities
   */
  private detectCrossVenueArbitrage(
    symbol: string,
    venues: Map<string, OrderBook>
  ): AlphaOpportunity | null {
    let maxBid = { price: 0, size: 0, venue: '' };
    let minAsk = { price: Infinity, size: 0, venue: '' };
    
    // Find max bid and min ask across venues
    for (const [venue, orderBook] of venues) {
      if (orderBook.bids.length > 0) {
        const [bidPrice, bidSize] = orderBook.bids[0];
        if (bidPrice > maxBid.price) {
          maxBid = { price: bidPrice, size: bidSize, venue };
        }
      }
      
      if (orderBook.asks.length > 0) {
        const [askPrice, askSize] = orderBook.asks[0];
        if (askPrice < minAsk.price) {
          minAsk = { price: askPrice, size: askSize, venue };
        }
      }
    }
    
    // Check if profitable arbitrage exists
    const spread = maxBid.price - minAsk.price;
    const spreadBps = (spread / minAsk.price) * 10000;
    
    if (spreadBps > LIQUIDITY_CONFIG.aggregation.minVenues * 5) { // Dynamic threshold
      const size = Math.min(maxBid.size, minAsk.size);
      const profit = spread * size;
      
      return {
        id: `arb_${symbol}_${Date.now()}`,
        type: AlphaType.CROSS_VENUE,
        source: AlphaSource.CROSS_EXCHANGE,
        confidence: 0.85,
        expectedReturn: spreadBps,
        riskScore: 0.2,
        timeHorizon: 500, // 500ms window
        timeWindow: 500,
        capital: new BigNumber(minAsk.price * size),
        priority: spreadBps > 50 ? AlphaPriority.CRITICAL : AlphaPriority.HIGH,
        timestamp: Date.now(),
        metadata: {
          buyVenue: minAsk.venue,
          sellVenue: maxBid.venue,
          buyPrice: minAsk.price,
          sellPrice: maxBid.price,
          size,
          profit
        }
      };
    }
    
    return null;
  }

  /**
   * Detect market making opportunities
   */
  private detectMarketMakingOpportunity(
    symbol: string,
    spread: number
  ): AlphaOpportunity | null {
    const aggregated = this.aggregatedLiquidity.get(symbol);
    if (!aggregated) return null;
    
    const spreadBps = (spread / aggregated.midPrice) * 10000;
    const targetSpread = this.getTargetSpread(symbol);
    
    if (spreadBps > targetSpread && aggregated.totalBidLiquidity.plus(aggregated.totalAskLiquidity).gt(100000)) {
      return {
        id: `mm_${symbol}_${Date.now()}`,
        type: AlphaType.MARKET_MAKING,
        source: AlphaSource.ORDERBOOK_IMBALANCE,
        confidence: 0.7,
        expectedReturn: spreadBps / 2, // Capture half the spread
        riskScore: 0.3,
        timeHorizon: 60000, // 1 minute
        timeWindow: 60000,
        capital: new BigNumber(50000), // $50k inventory
        priority: AlphaPriority.NORMAL,
        timestamp: Date.now(),
        metadata: {
          currentSpread: spreadBps,
          targetSpread,
          bidLiquidity: aggregated.totalBidLiquidity.toString(),
          askLiquidity: aggregated.totalAskLiquidity.toString()
        }
      };
    }
    
    return null;
  }

  /**
   * Detect liquidity imbalances
   */
  private detectLiquidityImbalance(symbol: string): AlphaOpportunity | null {
    const aggregated = this.aggregatedLiquidity.get(symbol);
    if (!aggregated) return null;
    
    const imbalance = aggregated.totalBidLiquidity.minus(aggregated.totalAskLiquidity)
      .div(aggregated.totalBidLiquidity.plus(aggregated.totalAskLiquidity));
    
    if (Math.abs(imbalance.toNumber()) > 0.3) {
      const direction = imbalance.gt(0) ? 'buy' : 'sell';
      
      return {
        id: `imb_${symbol}_${Date.now()}`,
        type: AlphaType.LIQUIDITY_PROVISION,
        source: AlphaSource.ORDERBOOK_IMBALANCE,
        confidence: 0.6,
        expectedReturn: Math.abs(imbalance.toNumber()) * 20, // Convert to bps
        riskScore: 0.4,
        timeHorizon: 30000, // 30 seconds
        timeWindow: 30000,
        capital: new BigNumber(25000),
        priority: AlphaPriority.LOW,
        timestamp: Date.now(),
        metadata: {
          imbalance: imbalance.toNumber(),
          direction,
          suggestion: direction === 'buy' ? 'provide_ask_liquidity' : 'provide_bid_liquidity'
        }
      };
    }
    
    return null;
  }

  /**
   * Optimize execution path across venues
   */
  private optimizeExecutionPath(
    venues: VenueLiquidity[],
    side: 'buy' | 'sell',
    totalSize: BigNumber
  ): ExecutionStep[] {
    // Sort venues by best price and liquidity
    const sorted = venues.sort((a, b) => {
      const scoreA = a.available.toNumber() / (1 + a.spread);
      const scoreB = b.available.toNumber() / (1 + b.spread);
      return scoreB - scoreA;
    });
    
    const steps: ExecutionStep[] = [];
    let remaining = totalSize;
    let timeOffset = 0;
    
    for (const venue of sorted) {
      if (remaining.lte(0)) break;
      
      const size = BigNumber.min(remaining, venue.available);
      const prices = Object.keys(venue.depth).map(p => parseFloat(p));
      const avgPrice = side === 'buy' 
        ? Math.max(...prices)
        : Math.min(...prices);
      
      steps.push({
        action: side,
        venue: venue.venue,
        asset: 'unknown',
        amount: size.toNumber(),
        expectedPrice: avgPrice,
        maxSlippage: 0.01,
        timeout: 5000,
        size: size.toNumber()
      });
      
      remaining = remaining.minus(size);
      timeOffset += Math.random() * 50; // 0-50ms randomization
    }
    
    return steps;
  }

  /**
   * Calculate venue-specific spread
   */
  private calculateVenueSpread(orderBook: OrderBook): number {
    if (orderBook.bids.length === 0 || orderBook.asks.length === 0) {
      return Infinity;
    }
    
    const bestBid = orderBook.bids[0][0];
    const bestAsk = orderBook.asks[0][0];
    const midPrice = (bestBid + bestAsk) / 2;
    
    return ((bestAsk - bestBid) / midPrice) * 10000; // basis points
  }

  /**
   * Calculate weighted average spread
   */
  private calculateWeightedSpread(venues: VenueLiquidity[]): number {
    let totalWeight = new BigNumber(0);
    let weightedSum = new BigNumber(0);
    
    for (const venue of venues) {
      const weight = venue.available;
      totalWeight = totalWeight.plus(weight);
      weightedSum = weightedSum.plus(weight.times(venue.spread));
    }
    
    return totalWeight.gt(0) 
      ? weightedSum.div(totalWeight).toNumber()
      : 0;
  }

  /**
   * Estimate market impact
   */
  private estimateMarketImpact(
    orderSize: BigNumber,
    availableLiquidity: BigNumber
  ): number {
    const sizeRatio = orderSize.div(availableLiquidity).toNumber();
    
    // Simple square-root impact model
    const impact = 10 * Math.sqrt(sizeRatio); // basis points
    
    return Math.min(impact, 100); // Cap at 100bps
  }

  /**
   * Get target spread for a symbol
   */
  private getTargetSpread(symbol: string): number {
    // This would be more sophisticated in production
    // Could use historical volatility, volume, etc.
    return LIQUIDITY_CONFIG.provision.spreadTargets.normal;
  }

  /**
   * Initialize connections to all venues
   */
  private async initializeVenueConnections(): Promise<void> {
    // In production, this would connect to real exchanges
    // For now, we'll simulate with dummy data
    
    // Initialize order books for major pairs
    const symbols = ['BTC/USDT', 'ETH/USDT', 'SOL/USDT'];
    
    for (const symbol of symbols) {
      this.orderBooks.set(symbol, new Map());
      
      for (const venue of this.config.venues || []) {
        // Simulate initial order book
        this.orderBooks.get(symbol)!.set(venue, this.generateDummyOrderBook(symbol, venue));
      }
    }
  }

  /**
   * Clean up venue connections
   */
  private async cleanupVenueConnections(): Promise<void> {
    this.orderBooks.clear();
    this.aggregatedLiquidity.clear();
  }

  /**
   * Process order book updates from market state
   */
  private processOrderBookUpdates(updates: any[]): void {
    for (const update of updates) {
      const { symbol, venue, bids, asks, timestamp } = update;
      
      if (!this.orderBooks.has(symbol)) {
        this.orderBooks.set(symbol, new Map());
      }
      
      this.orderBooks.get(symbol)!.set(venue, {
        venue,
        symbol,
        bids,
        asks,
        timestamp
      });
    }
  }

  /**
   * Generate dummy order book for testing
   */
  private generateDummyOrderBook(symbol: string, venue: string): OrderBook {
    const basePrice = symbol.includes('BTC') ? 50000 : symbol.includes('ETH') ? 3000 : 100;
    const spread = basePrice * 0.0005; // 5bps spread
    
    const bids: Array<[number, number]> = [];
    const asks: Array<[number, number]> = [];
    
    // Generate 10 levels
    for (let i = 0; i < 10; i++) {
      const bidPrice = basePrice - spread/2 - i * spread/10;
      const askPrice = basePrice + spread/2 + i * spread/10;
      const size = Math.random() * 10 + 1;
      
      bids.push([bidPrice, size]);
      asks.push([askPrice, size]);
    }
    
    return {
      venue,
      symbol,
      bids,
      asks,
      timestamp: Date.now()
    };
  }

  /**
   * Get performance metrics
   */
  getPerformanceMetrics() {
    const avgLatency = this.aggregationLatency.length > 0
      ? this.aggregationLatency.reduce((a, b) => a + b, 0) / this.aggregationLatency.length
      : 0;
    
    return {
      opportunitiesFound: this.opportunitiesFound,
      avgAggregationLatency: avgLatency,
      activeSymbols: this.orderBooks.size,
      activeVenues: this.config.venues?.length || 0
    };
  }
} 
// Local type definitions
interface VenueLiquidity {
  venue: string;
  available: BigNumber;
  spread: number;
  depth: { [price: string]: BigNumber };
}

interface SmartLiquidityRoute {
  venues: VenueLiquidity[];
  aggregatedLiquidity: BigNumber;
  weightedSpread: number;
  executionPath: ExecutionStep[];
  estimatedImpact: number;
  confidence: number;
}
