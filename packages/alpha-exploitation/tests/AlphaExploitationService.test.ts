/**
 * Alpha Exploitation Service Tests
 */

import { AlphaExploitationService } from '../src/core/AlphaExploitationService';
import { DEFAULT_CONFIG } from '../src/config/default';
import { AlphaType, AlphaSource, AlphaPriority } from '../src/types';

describe('AlphaExploitationService', () => {
  let service: AlphaExploitationService;

  beforeEach(() => {
    service = new AlphaExploitationService();
  });

  afterEach(async () => {
    if (service.isRunning) {
      await service.stop();
    }
  });

  describe('initialization', () => {
    it('should initialize with default config', () => {
      expect(service).toBeDefined();
      expect(service.isRunning).toBe(false);
    });

    it('should accept custom config', () => {
      const customConfig = {
        ...DEFAULT_CONFIG,
        minConfidence: 0.9
      };
      
      const customService = new AlphaExploitationService(customConfig);
      expect(customService).toBeDefined();
    });
  });

  describe('lifecycle', () => {
    it('should start and stop successfully', async () => {
      await service.start();
      expect(service.isRunning).toBe(true);

      await service.stop();
      expect(service.isRunning).toBe(false);
    });

    it('should not start if already running', async () => {
      await service.start();
      expect(service.isRunning).toBe(true);

      // Second start should not change state
      await service.start();
      expect(service.isRunning).toBe(true);

      await service.stop();
    });
  });

  describe('opportunity processing', () => {
    beforeEach(async () => {
      await service.start();
    });

    it('should process valid opportunities', async () => {
      const opportunity = {
        id: 'test_001',
        type: AlphaType.ARBITRAGE,
        source: AlphaSource.CROSS_EXCHANGE,
        confidence: 0.8,
        expectedReturn: 25, // 25 bps
        riskScore: 0.2,
        timeHorizon: 1000,
        capital: DEFAULT_CONFIG.capitalAllocation.maxPerOpportunity.div(2),
        priority: AlphaPriority.HIGH,
        metadata: {
          symbol: 'BTC/USDT',
          venue: 'test'
        }
      };

      let processed = false;
      service.on('opportunity-processed', () => {
        processed = true;
      });

      await service.submitOpportunity(opportunity);
      
      // Give it time to process
      await new Promise(resolve => setTimeout(resolve, 100));
      
      expect(processed).toBe(true);
    });

    it('should reject opportunities below confidence threshold', async () => {
      const lowConfidenceOpp = {
        id: 'test_002',
        type: AlphaType.ARBITRAGE,
        source: AlphaSource.CROSS_EXCHANGE,
        confidence: 0.5, // Below default 0.75 threshold
        expectedReturn: 25,
        riskScore: 0.2,
        timeHorizon: 1000,
        capital: DEFAULT_CONFIG.capitalAllocation.maxPerOpportunity.div(2),
        priority: AlphaPriority.HIGH,
        metadata: {}
      };

      let rejected = false;
      service.on('opportunity-rejected', () => {
        rejected = true;
      });

      await service.submitOpportunity(lowConfidenceOpp);
      
      await new Promise(resolve => setTimeout(resolve, 100));
      
      expect(rejected).toBe(true);
    });

    it('should reject opportunities exceeding capital limits', async () => {
      const largeOpp = {
        id: 'test_003',
        type: AlphaType.ARBITRAGE,
        source: AlphaSource.CROSS_EXCHANGE,
        confidence: 0.8,
        expectedReturn: 25,
        riskScore: 0.2,
        timeHorizon: 1000,
        capital: DEFAULT_CONFIG.capitalAllocation.maxPerOpportunity.times(2), // Exceeds limit
        priority: AlphaPriority.HIGH,
        metadata: {}
      };

      let rejected = false;
      service.on('opportunity-rejected', (reason) => {
        if (reason.includes('capital')) {
          rejected = true;
        }
      });

      await service.submitOpportunity(largeOpp);
      
      await new Promise(resolve => setTimeout(resolve, 100));
      
      expect(rejected).toBe(true);
    });
  });

  describe('performance metrics', () => {
    beforeEach(async () => {
      await service.start();
    });

    it('should track performance metrics', () => {
      const metrics = service.getPerformanceMetrics();
      
      expect(metrics).toHaveProperty('opportunitiesIdentified');
      expect(metrics).toHaveProperty('successRate');
      expect(metrics).toHaveProperty('totalPnL');
      expect(metrics).toHaveProperty('sharpeRatio');
      expect(metrics.opportunitiesIdentified).toBe(0);
    });

    it('should update metrics after processing opportunities', async () => {
      const opportunity = {
        id: 'test_004',
        type: AlphaType.ARBITRAGE,
        source: AlphaSource.CROSS_EXCHANGE,
        confidence: 0.8,
        expectedReturn: 25,
        riskScore: 0.2,
        timeHorizon: 1000,
        capital: DEFAULT_CONFIG.capitalAllocation.maxPerOpportunity.div(2),
        priority: AlphaPriority.HIGH,
        metadata: {}
      };

      await service.submitOpportunity(opportunity);
      await new Promise(resolve => setTimeout(resolve, 100));

      const metrics = service.getPerformanceMetrics();
      expect(metrics.opportunitiesIdentified).toBeGreaterThan(0);
    });
  });

  describe('emergency controls', () => {
    beforeEach(async () => {
      await service.start();
    });

    it('should handle emergency stop', async () => {
      let emergencyTriggered = false;
      service.on('emergency-stop', () => {
        emergencyTriggered = true;
      });

      await service.emergencyStop();
      
      expect(emergencyTriggered).toBe(true);
      expect(service.emergencyStopActive).toBe(true);
    });
  });
});

// Component integration tests
describe('Component Integration', () => {
  let service: AlphaExploitationService;

  beforeEach(() => {
    service = new AlphaExploitationService();
  });

  afterEach(async () => {
    if (service.isRunning) {
      await service.stop();
    }
  });

  it('should initialize all components on start', async () => {
    await service.start();
    
    // Check if components are initialized (they should emit started events)
    let componentsStarted = 0;
    
    service.on('component-started', () => {
      componentsStarted++;
    });
    
    // Give time for async initialization
    await new Promise(resolve => setTimeout(resolve, 200));
    
    expect(service.isRunning).toBe(true);
  });

  it('should handle component failures gracefully', async () => {
    await service.start();
    
    let errorHandled = false;
    service.on('component-error', () => {
      errorHandled = true;
    });
    
    // Simulate component error (would need more sophisticated mocking in real tests)
    service.emit('component-error', new Error('Test error'));
    
    expect(errorHandled).toBe(true);
    expect(service.isRunning).toBe(true); // Service should continue running
  });
}); 